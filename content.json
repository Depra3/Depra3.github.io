{"posts":[{"title":"JAVA Spring Boot(STS - Spring Tools 4) 설치","text":"JAVA Spring Boot를 사용하기 위한 준비 Eclipse EE version은 2022-09(4.25.0) 설치 방법 링크 JAVA EE &amp; Apche Tomcat 설치 Help → Eclipse Marketplace… 클릭 (잠시 동안 로딩이 있을 수 있습니다.) sts 검색 → 최신 버전(현재는 Spring Tools 4가 최신) 찾기 → Install 클릭 Confirm 클릭 약 2~3분 정도 소요됩니다. ① 동그라미 체크 → ② Finish 클릭 붉은 박스 클릭하면 현재 진행도가 상세하게 나옵니다. 설치에 시간이 걸리니 커피 한 잔을 타고 와서 지켜봅시다.(약 4분 정도 소요됨) 설치 중간에 갑자기 Trust 창이 뜹니다. ① Select All 클릭 → ② Trust Selected 클릭 Restart Now 클릭 Eclipse가 다시 시작되니 한 잔 타 온 커피를 마시면서 기다려봅시다. ☆ TEST ☆ File 클릭 → New에 마우스 커서 놓기 → Other.. 클릭 ① spring 입력 (자동 검색) → ② Spring Starter Project 클릭 → ③ Next 클릭 ① Project 이름 / ② Gradle - Groovy로 설정 / ③ 클릭하여 8로 설정 / ④ 클릭하여 War로 설정 (글쓴이가 배운 설정입니다.) 설정 후 확인 ① spring web 입력 → ② 네모박스 체크 → ③ 선택되었는지 확인 → ④ Finish 클릭 그림과 같은 구조로 생성되는 것을 확인할 수 있습니다. 간혹 유효성 관련한 창이 뜨기도 하는데 검색해보니 검색을 잘 못하는 건지 찾기가 힘듭니다. 아무거나 클릭해도 무방할 듯 싶습니다.","link":"/2023/01/07/2023/01/JAVA_Spring_Boot_(STS-Spring_Tools_4)_Install/"},{"title":"JAVA EE &amp; Apche Tomcat 설치","text":"JAVA EE를 사용하기 위한 Eclipse 다운로드★ 다운로드 링크 ★Eclipse Packages | The Eclipse Foundation - home to a global community, the Eclipse IDE, Jakarta EE and over 350 open source projects… 아래의 그림에서 이용자의 운영체제에 맞게 선택하여 다운로드 어느 것을 선택하든 같은 것을 다운 받기 때문에 신경 쓰지 않고 다운로드 JDK 설치★ JDK 설치 및 환경 변수 설정 링크 ★Apache Tomct 다운로드★ 다운로드 링크 ★Apache Tomcat® 원하는 버전 선택 ( 글쓴이는 배운 환경과 같은 Tomcat 9를 이용 ) zip 클릭해서 다운로드 다운로드 한 폴더에 그대로 압축 풀기 eclipse 실행 원하는 경로로 설정하고 싶으면 ① Browse 클릭 기본 경로로 만들어서 사용한다면 그대로 ② Launch 클릭 ※ ① Browse 클릭했을 경우 원하는 경로 선택 후 폴더 선택 클릭 경로가 바뀐 것을 볼 수 있다. Launch 클릭하여 Eclipse 실행 아래 그림과 같이 나왔다가 실행이 된다. 작업하기 위한 기본 설정요약 Web &gt; CSS Files &gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Web &gt; HTML Files &gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Web &gt; JSP Files &gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Server &gt; Runtime Environments &gt; Add &gt; Apache &gt; Apache 버전 선택 &gt; Next &gt; Browse &gt; 압축 해제한 Apache Tomcat 폴더 클릭 &gt; 폴더 선택 클릭 &gt; Finish 클릭 &gt; 추가되었는지 확인 &gt; Apply and Close 클릭 상세 상단의 Window - Preferences 클릭 ① Web 좌측의 ‘**&gt;’** 클릭 → ② CSS Files 좌측의 ‘**&gt;**’ 클릭 → ③ Korean, EUC-KR 클릭 → ④ **ISO 10646/Unicode(UTF-8)**을 찾아 클릭 ( 스크롤을 맨 위에 올리면 있음 ) ① Apply 클릭하여 적용 → ② HTML Files 클릭 ① Korean, EUC-KR 클릭 → ② **ISO 10646/Unicode(UTF-8)**을 찾아 클릭 ( 위와 위치 동일함 ) → ③ Apply 클릭하여 적용 → ④ JSP Files 클릭 ① Korean, EUC-KR 클릭 → ② **ISO 10646/Unicode(UTF-8)**을 찾아 클릭 ( 위와 위치 동일함 ) → ③ Apply 클릭 ① Server 좌측의 ‘**&gt;**’ 클릭 → ② Runtime Environments 클릭 → ③ Add.. 클릭 ① Apache 좌측의 ‘**&gt;**’ 클릭 → ② 자신이 받은 Apache Tomcat 버전에 맞게 클릭 → ③ ‘②’를 진행하면 비활성화 되어 있는 Next 버튼이 활성화 되니 Next 클릭 글쓴이는 Apache Tomcat 9를 다운 받음 ① Browse.. 클릭 → 폴더 선택 창이 나옴 → ② 압축 해제한 Apache Tomcat 폴더 클릭 → ③ 폴더 선택 클릭 → ④ 활성화 된 Finish 클릭 추가 되었는지 확인 후 ① Apply and Close 클릭 Test ① Create a Dynamic Web project 클릭 → ② Project name에 원하는 이름 쓰기 → ③ Finish 클릭 ① webapp에서 마우스 오른쪽 클릭 → ② New에 마우스 커서를 놓기 → HTML File이 있다면 클릭 / 없다면 Other.. 클릭 ※ Other.. 클릭 후 ① html 입력하면 ② HTML File 이 자동으로 나옴 → ③ Next 클릭 ① Test.html 입력 → ② Next 클릭 Finish 클릭 예시로 “연동 확인 !!” 입력 ① Test.html 마우스 오른쪽 클릭 → ② Run As에 마우스 커서 놓기 → ③ Run on Server 클릭 ① 자신이 설치한 Tomcat 버전 클릭 (글쓴이는 Tomcat 9 설치) → ② Next 클릭 Project Name인 Test있는지 확인 → Finish 클릭 연동 성공!","link":"/2022/12/27/2022/12/20/JAVA_EE_&_Apche_Tomcat_Install/"},{"title":"JAVA SE 설치","text":"Java SE 를 사용하기 위한 Eclipse 다운로드★ 다운로드 링크 ★The Community for Open Innovation and Collaboration | The Eclipse Foundation Download 클릭 Download Packages 클릭 사용자 컴퓨터에 따른 버전 링크 클릭 붉은 박스 클릭해서 다운로드 시작 다운로드 확인 ★ JDK 설치 및 환경 변수 설정 링크 ★","link":"/2022/12/19/2022/12/20/JAVA_SE_Install/"},{"title":"JDK 설치 및 환경 변수 설정","text":"JDK 설치★ 다운로드 링크 ★Download the Latest Java LTS Free Java 17 - Windows - 원하는 설치 방식으로 다운로드(zip이 편한 것 같아서 zip을 선택했습니다.) 이와 같이 원하는 폴더 안에 압축해제 환경 변수 설정 내 PC에서 마우스 오른쪽 클릭 후 속성 클릭 고급 시스템 설정 클릭 환경 변수(N)… 클릭 사용자 변수가 아닌 시스템 변수에서 새로 만들기 클릭 변수 이름(N)은 JAVA_HOME 변수 값(V)은 JDK파일을 압축 풀기하고 연 폴더 경로 (글쓴이는 D:\\AI_Class\\tools\\jdk-17.0.4.1의 위치에 있음) 모두 입력 후 확인 JAVA_HOME있는지 확인 Path 클릭 후 편집 클릭 새로 만들기 클릭 후 D:\\AI_Class\\tools\\jdk-17.0.4.1\\bin 나 %JAVA_HOME%\\bin 중 “하나” 쓰시면 됩니다. 이후 확인 누르며 빠져나오기 전부 확인을 눌러 설정 완료 참고 (CLASS PATH) Class Path는 Java Application이 사용하고 있는 Class가 여러 경로로 분산 되어 있을 때 하나로 모으기 위해 사용하는 방법 새로 만들기 클릭 CLASSPATH와 %JAVA_HOME%\\lib 입력 후 확인 설치 확인 시작메뉴 옆에서 cmd 입력 후 명령 프롬프트 실행 java -version 과 javac -version으로 확인 다음과 같이 나오면 설치 완료 java -version에서 오류가 나올 시에는 Eclipse가 제대로 설치가 되어있는지 확인 javac -version에서 오류가 나올 시에는 환경 변수 설정이 잘못되어 있을 가능 성이 높아 환경 변수 설정 확인","link":"/2022/12/19/2022/12/20/JDK_Install/"},{"title":"Visual Studio Code 설치 및 환경 설정","text":"코딩 작업 편의를 위한 VS Code 다운로드https://code.visualstudio.com/download 다양한 운영체제에서도 사용 가능 글쓴이는 Window 64bit를 사용하고 있어 x64중 System Installer를 다운 받음 동의 체크 후 다음 원하는 설치 경로 설정 후 다음 클릭(원하는 곳 없으면 그대로 설치해도 무방함) 시작 메뉴 관련 설정 후 다음 클릭 PATH에 추가 : 편의를 위해 체크하는 것을 추천 원하는 것 체크 후 다음 클릭 설치 클릭 설치 완료가 되었으니 Visual Studio Code가 잘 되는 지 실행 Visual Studio Code 실행 체크 후 종료 클릭 실행 화면 플러그 인한국어 설정 사용 시에 영어가 불편하다면 한국어로 설정 가능하다. korean만 입력했을 시 안나올 수도 있기 때문에 language까지 입력 우측 하단에 나오는 창에서 Change Language and Restart 클릭 한국어로 바뀐 것을 볼 수 있다. Live Server 현재 작성한 코드를 실시간으로 로컬 서버로 보여주는 기능. 저장(Ctrl + S)을 하면 실시간으로 웹브라우저에 반영이 된다. 단축키로는 Alt + L 을 입력하고 그 다음에 Alt + O 를 입력해야한다.","link":"/2023/06/18/2023/06/Visual_Studio_Code_Install/"},{"title":"Git &amp; Github 연결 설정","text":"☆ 다운로드 링크 ☆Git Downloads 사용자가 사용하는 OS(운영체제) 선택하여 다운로드 합니다. ( 글쓴이는 Windows 10이므로 Windows 선택 ) 사용자가 사용하는 OS bit를 선택하여 다운로드 합니다. ( 글쓴이는 64bit이므로 64bit 선택 ) 설치 후 실행. (Default) 바탕화면에서 마우스 오른쪽 클릭 후 Git Bash here 클릭 git —version입력하여 설치 확인 ① code 클릭 → ② 클릭 git clone “링크” 바탕화면에 생긴 파일 위에 오른쪽 클릭 Visual Studio Code 로 실행(단, 환경변수가 설정되어야함) 참고 : Visual Studio Code 설치 및 환경 설정 해당 사이트(https://www.toptal.com/developers/gitignore)에서 사용하는 언어 입력] ex) Python, R 나온 텍스트 내용을 복사 VS Code에서 .gitignore에 붙여넣기(맨 아랫줄에 붙여넣기) 터미널 생성 후 powershell이 아닌 git bash로 체크 후 git add .gitignore 입력 나오는 오류는 로그인이 되지 않아서 발생함. 따라서 로그인해야함. 첫 줄은 로그인 ID, 두번째 줄은 닉네임으로 연결 git config —global user.email “연결할 해당 github 가입 Email” git config —global user.name “연결할 해당 github 닉네임” 마지막으로 git push ( 로컬(local branch)에서 원격 저장소(remot repository)로 보낼 때 사용하는 명령어) 로 마무리 나오는 사이트에서 Authorize 클릭 연결 완료 된 것 확인 아래 코드를 입력하여 업로드 git add . git commit -m “updated” ※ update부분은 git commit message의 내용 git push 변경이 되었는지 확인 File과 Repository를 같은 이름으로 하는 연결 방법 File명과 Repository를 같은 이름으로 한 후 File을 우클릭하여 Git Bash Here 실행 후 아래 부분의 코드를 한 줄 씩 입력","link":"/2023/06/21/2023/06/Git&Github/"},{"title":"Node.js - Github Blog","text":"★ 다운로드 링크 ★ Nodejs.org에서 설치 /Images/2023/06/Node.js-Github_Blog Add to PATH가 있는 지 확인 빨간 박스 체크 흐름대로 가면 아래와 같이 설치 완료 바탕 화면 - Git Bash Here 아래와 같이 순서대로 진행 - 이후 localhost:4000이 되는지 확인 npm install -g hexo-cli hexo init myblog(파일명) cd myblog/ hexo server 편의를 위해 VS Code이용하기 위해 아래와 같이 진행 Git Bash 창에서 code .입력 _config.yml 파일에서 사용할 url 입력 Github에서 Repository 생성 _config.yml 파일에서 deploy 내용 입력 터미널 열기 Git Bash로 접속 아래의 내용 순서대로 입력 npm install npm install hexo-server —save npm install hexo-deployer-git —save hexo generate hexo deploy 백업 폴더명과 Repository name과 항상 같아야함 / 배포 X 백업 O 차례대로 입력하거나 한번에 입력하여 연동 파일 백업 화면 관리 - https://hexo.io/ko/docs/front-matter 블로그 게시글 올리기 편하게 Notion을 이용해 올리는 방법 다운 받은 파일 압축 풀기 VS Code에서 이미지 경로 입력 Github에 올리기 git add . git commit -m “updated” git push Github 블로그에 배포하기 hexo generate hexo deploy (배포) hexo server (배포 전 확인용)","link":"/2023/06/22/2023/06/Node.js-Github_Blog/"},{"title":"정보처리 산업기사(2023) 1과목-1장-①","text":"정보 시스템 기반 기술1장 응용 SW 기초 기술 활용 Key Words 운영체제, UNIX, 커널, 쉘, IP6, OSI 참조 모델, 라우터, 프로토콜, TCP, UDP 운영체제 운영체제의 목적 ( OS : Operating System) 처리 능력 (Throughtput) 반환 시간 (Turn Around Time) 사용 가능도 (Availability) 신뢰도 (Reliability) 운영체제의 기능 (os) 프로세서, 기억 장치, 입출력 장치, 파일 및 정보 관리 스케줄링, 인터페이스, 공유 기능, 자원 보호 기능, 입출력 장치 보조 기능, 가상 계산기 기능 제공 시스템 오류 검사, 복구 하드웨어와 네트워크 관리 및 제어 커널의 기능 : 운영체제 주요 자원 관리 [ 프기주파 ] 프로세스 관리 기억 장치 관리 주변 장치 관리 파일 관리 쉘의 기능 : 사용자 인터페이스, 명령어 해석 운영체제 종류 Windows, MacOS, UNIX, LINUX (다중 작업 처리) MS-DOS (단일 작업 처리) Windows windows는 1990년대 마이크로소프트 사가 개발한 운영체제이다. 특징 그래픽 사용자 인터페이스 (GUI) 키보드 명령어를 직접 입력하지 않고 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식 선점형 멀티태스킹 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료 시키고 모든 시스템 자원을 반환하는 방식 PnP(자동 감지 기능) ( Plug and Play ) 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때 해당 하드웨어를 사용하는 데 필요한 환경을 운영체제가 자동으로 구성해 주는 기능 OLE (Object Linking and Embedding) 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능 255자의 긴 파일 명 Windows에서는 파일 이름을 지정할 때 VFAT를 이용하여 최대 255자까지 지정할 수 있다.파일 이름으로는 / / : * ? &lt; &gt; | 를 제외한 모든 문자 및 공백을 사용할 수 있으며 한글의 경우 127자까지 지정할 수 있다. Single-User 시스템컴퓨터 한 대를 한 사람만이 독점해서 사용한다. Windows 기본 명령어 UNIX 개요 및 특징 [ 대다이계통 ] 1960년대 AT&amp;T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제 대화식 운영체제 ( 시분할 시스템을 위함 - 개방형 시스템 ) 다중 작업, 다중 사용자 이식성 ( C언어로 작성 ) 계층적 트리 구조 파일 많은 네트워킹 기능으로 통신망 관리용 운영체제로 적합 UNIX 시스템 구성 커널 (Kernel) UNIX의 핵심적인 부분 부팅시 주기억장치에 적재된 후 상주하면서 실행 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할 담당 프로세스(CPU 스케줄링) 관리, 기억 장치 관리, 파일 관리, 입 출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 기능을 수행 쉘 (Shell) 명령어 해석기 시스템과 사용자간의 인터페이스 담당 DOS의 COMMAND와 같은 기능 수행 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재, 보조 기억 장치에서 교체 처리 가능 파이프라인 기능을 지원하고 입 출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다. 공용 Shell이나 사용자 자신이 만든 Shell을 사용할 수 있다. Utility Program 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용한다. DOS에서의 외부 명령어에 해당한다. 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다. UNIX &amp; LINUX 기본 명령어 인터넷 인터넷 IP주소 (Internet Protocol Address) 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소 숫자로 8비트씩 4부분, 총 32비트 표현 A클래스에서 E클래스까지 총 5단계로 구성 A Class: 국가나 대형 통신망에 사용(0~127로 시작) B Class: 중대형 통신망에 사용(128~191로 시작) C Class: 소규모 통신망에 사용(192~223으로 시작) D Class: 멀티캐스트용으로 사용(224~239으로 시작) E Class: 실험적 주소이며 공용되지 않음 서브네팅 (Subnetting) 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용 4byte의 IP주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다. 서브넷 마스크는 각 클래스마다 다르게 사용된다. IPv6 (Internet Protocol Version 6) 현재 사용하고 있는 IP주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발 128bit의 긴 주소를 사용하여 주소 부족 문제를 해결, IPv4에 비해 자료 전송 속도가 빠름 인증성, 기밀성, 무결성의 지원으로 보안 문제를 해결 IPv4와 호환성이 뛰어남 주소의 확장성, 융통성, 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다. IPv6의 구성 [ 유멀애 ] 16bit씩 8부분, 총 128bit로 구성 각 부분을 16진수로 표현, 콜론(:)으로 구분 3가지 주소 체계 유니캐스트(1:1), 멀티캐스트(1:N), 애니캐스트(가까이 있는 1:1) 도메인 네임 도메인 네임은 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현 호스트 컴퓨터 이름, 소속 기관 이름, 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미한다.","link":"/2023/06/23/2023/06/1%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A0/"},{"title":"정보처리 산업기사(2023) 1과목-1장-②","text":"OSI 참조 모델 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol) OSI 7계층은 1~3계층을 하위 계층, 4~7계층을 상위 계층으로 구분 하위 : 물리 → 데이터 링크 → 네트워크 상위 : 전송 → 세션 → 표현 → 응용 OSI참조모델 데이터 단위 물리 : 비트 데이터 : 프레임 네트워크 : 패킷 전송 : 세그먼트 세션, 표현, 응용 : 메세지 OSI 참조 모델 계층 물리 계층 전송에 필요한 두 장치 간의 기계적, 전기적, 기능적, 절차적 특정에 대한 규칙 정의 데이터 링크 계층 두 개의 인접한 개방 시스템들 간의 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 “시스템 간” 연결 설정과 유지 및 종료 담당, 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어 네트워크 계층 데이터의 교환 및 중계, “네트워크” 연결 설정 / 유지 / 해제 기능, 경로 설정(Routing) 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행 전송(Transport) 계층 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(end-to-end)간의 투명한 데이터 전송 가능 E-T-E간의 전송 연결 설정, 데이터 전송, 연결 해제 기능 세션 계층 송수신 측간의 관련성 유지 대화 구성 및 동기 제어, 데이터 교환 관리, 동기점 표현(presentation) 계층 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신을 적당한 형태로 변환, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 응용 계층 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스 제공 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 서비스 네트워크 관련 장비 네트워크 인터페이스 카드 (NIC) 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경 물리 허브 (Hub) 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며 신호 증폭 기능을 하는 리피터의 역할도 포함 더미 허브, 스위칭 허브 리피터 (Repeater) 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행 데이터 브릿지 (Bridge) LAN과 LAN 또는 LAN안에서 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다. 스위치 (Switch) 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치 하드웨어를 기반으로 처리하므로 전송 속도가 빠르다. 네트워크 라우터 (Router) 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가 된 것으로 서로 다른 LAN이나 LAN과 WAN의 연결도 수행 전송 게이트웨이 (Gateway) 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행한다. LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 한다. 프로토콜 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약 구문(Syntax): 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정 의미(Semantics): 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정 시간(Timing): 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정 프로토콜의 기능 단편화와 재결합 단편화(Fragmentation) 송신 측에서 전송할 데이터를 전송에 알맞은 일정 크기의 작은 블록으로 자르는 작업 재결합(Reassembly) 수신 측에서 단편화된 블록을 원래의 데이터로 모으는 작업 캡슐화(Encapsulation) 단편화된 데이터에 송 수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로 요약화라고 한다. 흐름 제어(Flow Control) 수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능 정지-대기(Stop-and-wait), 슬라이딩 윈도우(Sliding Window)방식을 이용 오류 제어(Error Control) 전송 중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능 동기화(Synchronization) 송 수신 측이 같은 상태를 유지하도록 타이밍(Timing)을 맞추는 기능 순서 제어(Sequencing) 전송되는 데이터 블록(PDU)에 전송 순서를 부여하는 기능 연결 위주의 데이터 전송 방식에만 사용 주소 지정(Addressing) 데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능 다중화(Multplexing) 한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능 경로 제어(Routing) 송 수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능 전송 서비스 전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스 TCP/IP 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜 TCP 프로토콜과 IP 프로토콜이 결합된 것을 의미 응용 계층, 전송 계층, 인터넷 계층, 네트워크 엑세스 계층으로 이루어져 있다. IP - 네트워크 계층 해당, TCP - 전송 계층 해당 응용 계층의 주요 프로토콜 FTP, SMTP, TELNET, SNMP, DNS, HTTP, MQTT FTP 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜 SMTP 전자 우편을 교환하는 서비스 TELNET 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행 SNMP TCP/IP의 네트워크 관리 프로토콜로 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는데 사용되는 표준 통신 규약 DNS 도메인 네임을 IP 주소로 매핑하는 시스템 HTTP 월드 와이드 웹(www)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜 MQTT 무선으로 네트워크에 연결된 비교적 단순한 기기들 간의 간단한 소통을 목적으로 만들어진 만큼 리소스를 매우 적게 요구하기 때문에 사물 인터넷에 최적화된 프로토콜 경량성, 이식성, 유연성, 안정성 전송 계층의 주요 프로토콜 TCP, UDP, RTCP TCP [ 신뢰성, 연결 지향적, 흐름 제어, 혼잡 제어 ] 양방향 연결형 서비스를 제공한다. 스트럼 위주의 전달(패킷 단위)을 한다. 신뢰성 있는 경로를 확립하고 메시지 전송을 감독한다. 순서 제어, 오류 제어, 흐름 제어 기능을 한다. TCP 프로토콜의 헤더는 기본적을 20byte~60byte까지 사용 가능하나 선택적으로 40byte를 더 추가 할 수 있어 최대 100byte까지 크기 확장 가능하다. UDP [ 체대소다랭 ] Checksum, Destination, Source Port Number, Data, Length / 아래 참고 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공한다. / 신뢰성 無 TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 오버헤드가 적고 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다. 실시간 전송에 유리하며 신뢰성보다는 속도가 중요시되는 네트워크에서 사용된다. RTCP 데이터 전송 모니터링, 최소한의 제어와 인증 기능, 32비트 경계로 끝남 RTP 패킷의 전송 품질을 제어하기 위한 제어 프로토콜이다. 세션에 참여한 참여자들에게 주기적으로 제어 정보를 전송한다. 인터넷(네트워크) 계층의 주요 프로토콜 IP 전송할 데이터에 주소를 지정하고 경로를 설정하는 기능을 한다. 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않는다. ICMP IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하며 헤더는 8byte로 구성된다. IGMP 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용된다. ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꾼다. RARP ARP와 반대로 물리적 주소를 IP 주소로 반환하는 기능을 한다. 네트워크 엑세스 계층의 주요 프로토콜 Ethernet - IEEE 802.3 CSMA/CD 방식의 LAN IEEE 802 LAN을 위한 표준 프로토콜 802.7 - 미디어 액세스 제어 프로토콜 802.9 - ISLAN(Integrated Services LAN) 802.10 - 보안 서비스 802.16 - 광대역 무선 액세스(BWA : Broadband Wireless Access) / 대역폭이 넓은 무선 접속(WiMAX) 802.22 - TV White Space HDLC 비트 위주의 데이터 링크 제어 프로토콜 프레임 구조 순서 플래그 → 주소부 → 제어부 → 정보부 → FCS → 플래그 동작 모드 정규(표준) 응답 모드(NRM), 비동기 응답모드(ARM), 비동기 균형(평형) 모드(ABM ) X.25 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 RS-232C 공중 전화 교환망(PSTN)을 통한 DTE(데이터 단말 장치)와 DCE(데이터 회선 종단 장치) 간의 인터페이스를 제공하는 프로토콜 TCP 포트번호 모뎀 아날로그 회선에서 사용, 디지털 데이터를 아날로그 신호로 변환하거나 그 역의 기능을 함 DSU (Digital Service Unit) - 가입자 측 장비 디지털 회선에 사용, 디지털 데이터를 디지털 신호로 변환 신호의 변복조 방식이 단순하고 저속, 고속 전송 시에 효과적 CSU (Channel Service Unit) - 망 측 장비 T1 및 E1과 같은 트렁크 라인을 그대로 수용할 수 있는 데이터 통신 전용 장비 디지털 트렁크 회선과의 직접 연결에 이용하는 가입자 전송 장치","link":"/2023/06/24/2023/06/1%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A1/"},{"title":"JAVA-예약어","text":"JAVA에서 사용하는 의미가 약속된 단어들이다. 변수 이름 또는 메서드 이름으로 선언 할 수 없다. 기본 데이터 타입 boolean, byte, int, long, float, double, char, short 접근 지정자 private, protected, public 클래스 관련 class, abstract, interface, extends, implements 등 객체 관련 new, instanceof, this. super, null 등 메소드 관련 void, return 제어문 관련 if, else, switch, break, continue, for, while 등 논리 리터널 true, false 기타 try, catch, finally, throw, true, false 등 참고 자료 : 자바_예약어","link":"/2023/06/26/2023/06/JAVA-%EC%98%88%EC%95%BD%EC%96%B4/"},{"title":"JAVA-변수","text":"변수 하나의 값을 저장하는 메모리 공간 변수를 사용하는 것은 변수에 값을 저장 및 활용하는 것을 의미한다. 변수 선언 변수를 사용하기 위해서는 변수 타입과 변수 이름을 선언해야 한다. 예시 : “ 타입 변수이름; ” 123int a; // 정수값을 저장할 수 있는 a 변수 선언double b; // 실수값을 저장할 수 있는 b 변수 선언int c, d, e; // 정수값을 저장할 수 있는 c, d, e 변수들 선언 변수명 작성 규칙 첫 번째 글자는 문자, $, _ 이어야 하고, 숫자가 될 수 없음 abc, $abc, _abc 영어 대/소문자 구분 Abc와 abc는 서로 다른 문자 관례로 첫 문자는 소문자로 시작, 다른 단어와 혼용할 경우 대문자로 구분 appleBanana 자바 예약어는 사용 불가 참조 : JAVA-예약어 문자 수는 제한 없음","link":"/2023/06/27/2023/06/JAVA-%EB%B3%80%EC%88%98/"},{"title":"JAVA-데이터타입","text":"데이터 타입 정수형 타입 선언 및 출력 byte, short, int, long타입들을 이용하며, 실수 입력 시에 오류가 발생한다. 코드 123456789byte a = 1;short b = 2;int c = 3;long d = 4;System.out.println(a);System.out.println(b);System.out.println(c);System.out.println(d); 결과 문자형 타입 선언 및 출력 char타입이며 입출력 시에 ASCII를 참조한다. 코드 12345char a = 'a';char b = 65;System.out.println(a);System.out.println(b); char타입에서는 작은 따옴표(’ ’)를 사용 큰 따옴표(” ”)는 String객체를 이용하여 문자열 변수 선언시 사용 결과 char 타입에 숫자도 입력 받을 수 있으나 출력은 ASCII을 참조하여 출력한다. 참고 자료 : ASCII -위키백과 논리형 타입 선언 및 출력 boolean타입이며 참(True 또는 1), 거짓(False 또는 0) 2가지 값을 사용한다. 코드 12345boolean a = true;boolean b = false;System.out.println(a);System.out.println(b); 결과 실수형 데이터 타입 부동소수점 표현 방식을 사용 부호 : 1bit에서 +를 0으로, -를 1로 표현한다. 지수 : 지수부분을 표현 예시 : $2^5$ 에서 5가 지수 부분 가수 : 소수점 우측의 숫자 부분을 표현한다. 참고 자료 : 부동소수점 - 위키백과 코드 1234567float a = 1.5f;double b = 2.0;double c = 3.0d;System.out.println(a);System.out.println(b);System.out.println(c); JAVA에서는 실수 선언 시에 double자료형을 기본으로 한다. ( →3.0d에서 d는 생략 가능) 따라서, float 선언 부분에서 f가 붙는 이유이기도 하다. 결과","link":"/2023/06/28/2023/06/JAVA-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"title":"정보처리 산업기사(2023) 1과목-2장-①","text":"정보 시스템 기반 기술2장 애플리케이션 설계 폭포수 모형, 나선형 모형, 애자일, 스크럼, XP, UML, UML 다이어그램, 클래스, 캡슐화, 디자인 패턴 소프트웨어 생명주기 정의 소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로 소프트웨어를 개발하기 위해 정의하고 운용 유지보수 등의 과정을 각 단계로 나눈 것이다. 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 및 활동의 결과에 대한 산출물로 표현한다. 소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며 소프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고 한다. 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 소프트웨어 공학 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이며 여러가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다 소프트웨어 위기의 현상 여려 가지 원인에 의해 소프트웨어 개발 속도가 하드웨어 개발 속도를 따라가지 못해 소프트웨어에 대한 사용자들의 요구 사항을 처리할 수 없는 문제가 발생함을 의미합니다. 개발 인력 부족과 그로 인한 인건비 상승 개발 기간 지연 및 개발 비용 증가 유지 보수의 어려움과 이에 따른 비용 증가 소프트웨어의 생산성과 품질 저하 소프트웨어 개발 프로세스 폭포수 모형 (Waterfall Model) 이전 단계로 돌아갈 수 없다는 전제 하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론 고전적 생명 주기 모형 선형 순차적 모형 : 한 단계가 끝나고 다음 단계로 넘어감 경험과 성공 사례 많음 메뉴얼 작성 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다 두 개 이상의 과정 병행 불가 프로토타입 / 프로토타이핑 모형 (Prototyping Model) 사용자와 시스템 사이의 인터페이스 중점 완료되면 오류가 발견되는 폭포수의 단점을 보완 사용자의 요구 사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물 예측 나선형 모형 = 점진적 모형 (Spiral Model) 보헴(Boehm)이 제안한 것으로 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형 ( 폭포수 + 프로토타입 + 분석 기능 추가 ) 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것으로 점진적 모형 위험을 관리하고 최소화하는 목적 점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구 사항을 첨가할 수 있고, 정밀하며, 유지 보수 과정이 필요 없음 애자일 모형 애자일은 민첩한, 기만한이라는 의미로 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭 스프린트, 이터레이션 짧은 개발 주기 에자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼,XP,칸반,Lean,크리스탈,ASD,기능 중심 개발, DSDM, DAD 등이 있다. 애자일 개발 4가지 핵심 가치 프로세서와 도구 보다 개인과 상호작용에 초점 문서보다 실행되는 SW에 가치를 둠 고객과의 협업 가치 계획을 따르기 보다 변화에 반응 소프트웨어 방법론 구조적, 정보공학, 객체 지향, 컴포넌트(CBD) 기반, 애자일, 제품 설계 방법론 구조적 방법론 1960 년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론 정형화된 분석 절차에 따라 사용자 요구 사항을 파악하여 문서화 하는 처리 중심 방법론 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적 복잡한 문제를 다루기 위해 분할과 정복 원리 적용 정보 공학 방법론 정보 시스템 개발을 위해 계획, 분석, 설계 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합 절차 정보 전략 계획 수립 단계 → 업무 영역 분석 단계 → 업무 시스템 설계 단계 → 업무 시스템 구축 단계 객체 지향 방법론 하나의 객체로 만들어 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택 객체 지향 방법론 구성 요소 [ 객클메 ] 객체, 클래스, 메세지 등 객체 지향 방법론 기본 원칙 [ 정관다 캡상추 ] 정보은닉, 관계성, 다형성, 캡슐화, 상속성, 추상화 절차 요구 분석 단계 → 설계 단계 → 구현 단계 → 테스트 및 검증 단계 → 인도 단계 컴포넌트 기반(CBD) 방법론 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론 컴포넌트의 재사용이 가능하며 시간과 노력을 절감 새로운 기능 추가가 간단하여 확장성 보장 유지 보수 비용 최소화하고 생산성 및 품질을 향상 시킬 수 있음 절차 개발 준비 단계 → 분석 단계 → 설계 단계 → 구현 단계 → 테스트 단계 → 전개 단계 → 인도 단계 애자일 방법론 애자일은 민첩한, 기만한이라는 의미로 애자일 방법론은 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구 사항에 적합 대표적인 종류에는 익스트럼 프로그래밍, 스크럼,칸반,크리스탈 등 절차 사용자 스토리 → 반복 주기 [ 계획 → 개발 → 승인 테스트 ] 요구 사항 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약 조건 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공 요구 사항의 유형 기능 요구 사항 시스템이 무엇을 하는지 / 입력이나 출력으로 무엇이 포함되어야 하는지 / 반드시 수행해야 하는 기능 / 제공 받기를 원하는 기능 비기능 요구 사항 장비 구성 / 성능 / 인터페이스 / 데이터 / 테스트 / 보안 / 품질 / 제약 사항 / 프로젝트 관리 / 프로젝트 지원 사용자 요구 사항 사용자 관점에서 본 시스템 제공, 사용자를 위한 친숙한 표현 시스템 요구 사항 = 소프트웨어(SW) 요구 사항 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구 사항, 전문적이고 기술적인 용어 표현 요구 사항 개발 프로세스 요구 사항을 체계적 도출, 분석한 후 명세서 정리, 확인 및 검증 도출 (Elicitation) → 분석 (Analysis) → 명세 (Specification) → 확인 (Validation) 요구 사항 도출 인터뷰, 설문, 브레인 스토밍, 워크샵, 프로토파이핑, 유스케이스 (기능적 요구 사항) 요구 사항 분석 자료 흐름도 (DFD), 자료 사전(DD) 요구 사항 명세 사용자가 이해하기 쉽고 개발자가 효과적으로 설계할 수 있도록 작성 (문서화) 소단위 명세 (Mini-Spec) 요구 사항 확인 = 요구 사항 검증 요구 사항 정의 문서들에 대해 형상 관리 수행 구조적 분석 도구 종류 자료 흐름도 (DFD), 자료 사전 (DD), 소단위 명세서(Mini-Spec), 개체 관계도 (ERD), 상태 전이도(STD), 제어 명세서 모델링, 하향식 방법 등을 사용 자료 흐름도 (DFD) : 자료 흐름도 - IT위키 (itwiki.kr) 요구 사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트 자료 사전 (DD) 자료, 자료들의 집합, 자료의 흐름, 자료 저장소와 그것들의 관계-범위-단위를 구체적으로 명시하는 것 = : 사용자 정의 is |, [] : 자료의 선택 or : 자료의 연결 and { } : 자료의 반복 ( ) : 자료의 생략 ** : 자료의 설명 주석 요구 사항 분석을 위한 CASE 요구 사항 분석을 위한 자동화 도구 요구 사항을 자동으로 분석, 요구 사항 분석 명세서 기술 SADT SoftTech 시에서 개발한 것으로 시스템 정의, 소프트웨어 요구 사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 블록 다이어그램을 채택 SREM TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구 사항을 명확히 기술하도록 할 목적으로 개발한 것으로 **RSL과 REVS를 사용하는 자동화 도구**이다. RSL: 요소, 속성, 관계, 구조들을 기술하는 요구 사항 기술 언어 REVS: RSL로 기술된 요구 사항들을 자동으로 분석하여 요구 사항 분석 명세서를 출력하는 요구 사항 분석기 PSL/PSA 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용하는 자동화 도구이다. PSL (Problem Statement language) : 문제 기술 언어 PSA (Problem Statement Analyzer) : PSL로 기술한 요구 사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기 TAGS 시스템 공학 방법 응용에 대한 자동 접근 방법으로 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다.","link":"/2023/06/30/2023/06/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A0/"},{"title":"정보처리 산업기사(2023) 1과목-2장-②","text":"정보 시스템 기반 기술HIPO (Hierarchy Input Process Output) 시스템의 분석 및 설계나 문서화할 때 사용되는 기법, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타낸다. 하향식 기법 기본 시스템 모델은 입력, 처리, 출력으로 구성, 하향식 소프트웨어 개발을 위한 문서화 도구 체계적인 문서 관리 기능 기호, 도표 등 사용으로 이해가 쉬움 변경, 유지 보수 용이 가시적 도표 (VTC), 총체적 도표 (OD), 세부적 도표 (DD) HIPO Chart의 종류 가시적 도표(도식 목차) 시스템 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도 총체적 도표(총괄도표, 개요도표) 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표 세부적 도표(상세 도표) 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표 UML [ 사관다 ] 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통을 위한 객체 지향 모델링 언어 사물 (Things), 관계(Relationship), 다이어그램(Diagram) 다이어그램 사물과 관계를 도형으로 표현한 것 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움 정적 모델링에서는 주로 구조적 다이어그램을 사용, 동적 모델링에서는 주로 행위 다이어그램을 사용 구조 다이어그램 클래스 다이어그램: 클래스의 구조, 속성, 메서드, 관계 등을 보여줍니다. 시스템의 구조를 파악하고 구조상의 문제점을 도출 객체 다이어그램: 객체 간의 관계, 객체의 속성, 상태 등을 보여줍니다. 람바우 객체지향 분석 기법에서 객체 모델링에 활용 컴포넌트 다이어그램 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현 구현 단계에서 사용되는 다이어그램 패키지 다이어그램 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현 복합체 구조 다이어그램 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현 배치 다이어그램 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현 노드와 의사소통(통신) 경로로 표현 구현 단계에서 사용되는 다이어그램 행위 다이어그램 유즈케이스 다이어그램 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용한다. 사용자와 사용 사례로 구성되며 사용 사례 간에는 여러 형태의 관계로 이루진다. 상태 다이어그램 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현 럼바우 객체지향 분석 기법에서 동적 모델링에 활용 시퀀스 다이어그램 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현 구성 요소 활동 다이어그램 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현 커뮤니케이션 다이어그램 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데 메시지뿐만 아니라 객체들간의 연관까지 표현 상호작용 개요 다이어그램 상호작용 다이어그램 간의 제어 흐름을 표현 타이밍 다이어그램 객체 상태 변화와 시간 제약을 명시적으로 표현 소프트웨어 아키텍처의 설계 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체 소프트웨어 개발 시 적용되는 원칙과 지침이며 이해 관계자들의 의사소통 도구로 활용 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있음 설계 단계는 크게 상위 설계와 하위 설계로 구분 협약에 의한 설계 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. 협약에 의한 설계 시 명세에 포함될 조건에는 선행 조건, 결과 조건, 불변 조건이 있다.","link":"/2023/07/01/2023/07/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A1/"},{"title":"정보처리 산업기사(2023) 1과목-2장-③","text":"1과목-2장-③아키텍처 패턴 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 아키텍처 스타일 또는 표준 아키텍처 장점 시행착오를 줄여 개발 시간을 단축시키고 고품질의 소프트웨어를 생산할 수 있다. 검증된 구조로 개발하기 때문에 안정적인 개발이 가능하다. 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다. 시스템 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지보수를 수행할 수 있다. 시스템의 특성을 개발 전에 예측하는 것이 가능 레이어 패턴 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이루며 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다. 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다. 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다. 대표적으로 OSI 참조 모델이 있다. 장단점 장점 : 정보 은닉의 원칙 적용 → 높은 이식성 단점 : 추가적인 실행시 오버헤드(너무 많은 계층으로 성능 감소 발생) 클라이언트 - 서버 패턴 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다. 클라이언트-서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉, 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다. 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다. 장단점 장점 : 직접적으로 데이터 분산, 위치 투명성 제공 단점 : 서비스와 서버의 이름을 관리하는 레지스터 부재로 이용 가능 서비스 탐색 불편 파이프-필터 패턴 (Pipe-Filter-Pattern) 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장에 용이함 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능 변환, 버퍼링, 동기화에 주로 사용 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 생김 대표적으로 UNIX의 쉘 장단점 장점 : 필터 교환과 재조합을 통한 높은 유연성 제공 단점 : 상태 정보 공유를 위한 고비 용과 데이터 변환 과부화 모델 - 뷰 - 컨트롤러 패턴 서브시스템을 3개의 부분으로 구조화하는 패턴이다. 모델(Model): 서브시스템의 핵심 기능과 데이터를 보관한다. 뷰(View): 사용자에게 정보를 표시한다. 컨트롤러(Controller): 사용자로부터 받은 입력을 처리한다. 장단점 장점 : 동일한 모델, 다양한 뷰 제공 및 뷰 동기화로 실시간 변경 데이터 제공 단점 : 단순 어플리케이션은 복잡성증가 모델-뷰-컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다. 모델-뷰-컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로하는 대화형 애플리케이션에 적합하다. 기타 패턴 PTP 장점 : 분산컴퓨팅 어플 구축시 유연성 제공 블랙보드 장단점 장점 : 다양한 접근법, 유지보수성,가변성,재사용 가능한 지식자원 단점 : 테스팅 어려움, 완전한 해결책 미보장 브로커 장단점 장점 : 위치 투명성, 연동 용이, 재사용 컴포넌트 확보 용이 단점 : 성능 불이익, 장애 대처 어려움, 디버깅 어려움 객체 지향 설계 원칙 = SOLID 원칙 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙 객체 지향 [ 객클메 ] , [ 정관다 캡상추 ] 참고 : 객체지향 개발방법론 - 해시넷 (hash.kr) 객클메 객체, 클래스, 메시지 정관다 캡상추 정보 은닉, 관계성, 다형성, 캡슐화, 상속성, 추상화 연관성 : 두 개 이상의 객체(클래스)들이 상호 참조하는 관계 is part of, is number of, in instance of, is a 객체 지향 분석의 방법론 Rumbaugh (럼바우) 방법 : 일반적으로 사용, 객체 모델, 동적 모델, 기능 모델 나누어 수행 Booch (부치) 방법 : 미시적, 거시적 개발 프로세스를 모두 사용 Jacobson 방법 : Use Case 강조하여 사용 Coad와 Yordon 방법 : E-R 다이어그램 사용 Wirfs - Brock 방법 : 분석과 설계가 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행 Rumbaugh(럼바우) 분석 기법 [ 객동기 ] 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로 객체 모델링 기법(OMT) 객체 모델링 ( 객체 다이어그램 표시 ) → 동적 모델링 ( 상태 다이어그램 ) → 기능 모델링 ( 자료 흐름도 - DFD - ) 디자인 패턴 참고 : 디자인 패턴 모듈 간의 인터페이스 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴. 디자인 패턴 사용의 장단점 범용적인 코딩 스타일로 인해 구조 파악이 용이하다. 객체 지향 설계 및 구현의 생산성을 높이는 데 적합하다. 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약된다. 초기 투자 비용이 부담될 수 있다. 개발자 간의 원활한 의사소통이 가능하다. 설계 변경 요청에 대한 유연한 대체가 가능하다. 객체 지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다. 생성 패턴 (추상 객체 인스턴스화) - [ 추팩 빌팩 프싱 ] 객체의 생성에 관련된 패턴으로 객체의 생성 절차를 추상화하는 패턴 추상 팩토리 패턴, 빌더 패턴, 팩토리 패턴, 프로토타입 패턴, 싱글톤 패턴 구조 패턴 (객체 간 결합) [ 어브컴 데파플프 ] 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴 어댑터, 브리지, 컴포지트, 데코레이터, 파사드, 플라이웨이트, 프록시 행위 패턴 (객체 간 커뮤니케이션) [ 책커 인반 중메 옵상 전템방 ] 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴 책임 연쇄(체인), 커맨드, 인터프리터, 반복자(이터레이터), 중재자. 메멘토, 옵저버, 상태, 전략, 템플릿 메소드, 방문자","link":"/2023/07/03/2023/07/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A2/"},{"title":"정보처리 산업기사(2023) 1과목-3장-①","text":"정보 시스템 기반 기술3장 테스트 및 배포 화이트 박스 테스트, 블랙박스 테스트, 단위 테스트, 통합 테스트, 하향식 통합 테스트, 상향식 통합 테스트, 결함, 사용자 인터페이스 (UI), 형상 관리, Git 화이트 박스 테스트 모듈의 원시 코드를 오픈 시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방식 절차에 초점을 맞춤, 테스트 과정의 초기에 적용, 모든 모듈 안의 작동을 직접 관찰 원시 코드(모듈)의 모든 문장을 한 번 이상 실행 선택, 반복 등 분기점 부분들을 수행함으로써 논리적 경로 제어 화이트 박스 테스트의 종류 기초 경로 검사 (Base Path Testing) 대표적인 화이트 박스 테스트 기법, 논리적 복잡성 측정, 실행 경로의 기초를 정의하는 데 지침으로 사용 제어 구조 검사 (Control Structure Testing) 조건 검사 (Condition Testing) : 논리적 조건 테스트 루프 검사 (Loop Testing) : 프로그램 반복 구조에 초점을 맞춤 데이터 흐름 검사 (Data Flow Testing) : 변수의 정의와 변수 사용 위치에 초점을 맞춤 블랙 박스 테스트 소프트웨어가 수행할 특정 기능을 알기 위해서 완전히 작동되는 것을 입증하는 테스트 기능 테스트라고도 함 사용자의 요구 명세를 보며 실시하는 테스트 사용자 인터페이스에서 실시 부정확 하거나 누락된 기능, 인터페이스 오류, 자료 구조나 외부 데이터베이스 접근에 따른 오류, 행위나 성능 오류, 초기화와 종료 오류 발견 테스트 과정의 후반부에 적용 블랙 박스 테스트의 종류 동치 분할 검사 = 동등 분할 기법 (Equivalence Partitioning Testing) 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법 경계값 분석 (Boundary Value Analysis) 동치 분할 기법을 보완하기 위한 기법 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법이다. 원인 효과 그래프 검사 (Cause-Effect Graphing Testing) 효용성이 높은 테스트 케이스를 선정하여 검사 오류 예측 검사 = 데이터 확인 검사 (Error Guessing) 블랙 박스 테스트 기법으로 찾을 수 없는 오류를 찾아내는 보충적 검사 기법 비교 검사 (Comparison Testing) 여러 버전의 프로그램에 동일한 테스트 자료 제공, 동일한 결과가 출력되는지 테스트 개발 단계에 따른 애플리케이션 테스트 SW 생명 주기 [ 요 설 구 테 유 ] / [ 요-분-설-구 ] / 소프트웨어 개발 단계 요구 사항 분석 → 설계 → 구현 → 테스트 → 유지 보수 테스트 단계 [ 단 통 시 인 ] 단위 테스트 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트 인터페이스, 외부적I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사 구조 기반 테스트 프로그램 내부 구조 및 복잡도를 검증하는 화이트 박스 테스트 실행 목적 : 제어 흐름, 조건 결정 명세 기반 테스트 목적 및 실행 코드 기반의 블랙박스 테스트 실행 목적 : 동등 분할, 경계 값 분석 통합 테스트 ( = 결합 테스트) 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사 점진적 모듈 통합 방법 : 하향식, 상향식 하향식 통합 테스트 ( Top Down Intergration Test ) 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트 하는 기법 주요 제어 모듈의 종속 모듈들은 Stub으로 대체 Stub : 함수 이름만 있거나 내용이 완전치 않은 코드 깊이 우선 (하위 계층 우선) or 넓이 우선(같은 계층 우선) 등의 통합 방식에 따라 하위 모듈인 Stub들이 한번에 하나씩 실제 모듈로 교체 모듈이 통합될 때 마다 테스트 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시 상향식 통합 테스트 ( Bottom Up Intergration Test ) 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트 하는 기법 Cluster가 필요 / Cluster : 하나의 주요 제어 모듈과 관련된 종속 모듈 그룹 하위 모듈들을 Cluster로 결합, 상위 모듈에서 Driver 작성 Driver : 더미 모듈 통합된 Cluster 단위로 테스트 테스트가 완료되면 Cluster프로그램 구조의 상위로 이동하여 결합하고 Driver는 실제 모듈로 대체 장점 : 위치 투명성, 연동 용이, 재사용 컴포넌트 확보 용이 단점 : 성능 불이익, 장애 대처 어려움, 디버깅 어려움 시스템 테스트 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는 가를 점검하는 테스트 환경적인 장애 리스크를 최소화하기 위해서는 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트를 수행 기능적 요구 사항과 비기능적 요구 사항으로 구분하여 각각을 만족하는지 테스트 기능적 요구 사항 요구 사항 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트 시행 비기능적 요구 사항 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 웹페이지의 네비게이션 등 구조적 요소에 대한 화이트 박스 테스트 시행 인수 테스트 개발한 소프트웨어가 사용자의 요구 사항을 충족하는 지에 중점을 두고 테스트 개발한 소프트웨어를 사용자가 직접 테스트 함 문제가 없으면 사용자는 소프트웨어를 인수 인수 테스트 6 종류 사용자 인수 테스트 사용자가 시스템 사용의 적절성 여부 확인 운영 상의 인수 테스트 시스템 관리자가 백업 / 복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인 계약 인수 테스트 인수 / 검수 조건을 준수하는 여부 확인 규정 인수 테스트 정부 지침, 법규, 규정에 맞게 개발 확인 알파 테스트 개발자의 장소에서 사용자가 개발자 앞에서 하는 테스트 기법 통제된 환경에서 행해지며, 오류와 문제점을 사용자와 개발자가 함께 확인하며 기록 베타 테스트 ( = 필드 테스트) 선정된 사용자가 여러 명의 사용자 앞에서 하는 테스트 기법(필드 테스팅) 실제 업무를 가지고 사용자가 직접 테스트 하는 것 개발자에 의해 제어되지 않는 상태에서 테스트 실행 발견된 오류와 문제점을 기록하고 개발자에게 주기적으로 보고","link":"/2023/07/07/2023/07/1%EA%B3%BC%EB%AA%A9-3%EC%9E%A5-%E2%91%A0/"},{"title":"정보처리 산업기사(2023) 1과목-3장-②","text":"정보 시스템 기반 기술3장 테스트 및 배포 화이트 박스 테스트, 블랙박스 테스트, 단위 테스트, 통합 테스트, 하향식 통합 테스트, 상향식 통합 테스트, 결함, 사용자 인터페이스 (UI), 형상 관리, Git 사용자 인터페이스 (UI) UI는 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어를 의미 UI의 특징 만족도에 가장 큰 영향을 미치며 변경이 가장 많이 발생 사용자의 가독성을 높임으로써 작업 시간 단축 최소한의 노력으로 원하는 결과 나올 수 있도록 한다. 오류를 줄이고 구체적인 방법 제공 사용자가 인터페이스를 설계하기 위해서는 소프트웨어 아키텍처를 반드시 숙지 사용자 인터페이스의 구분 CLI (Command Line Interface) 명령과 출력 테스트 형태로 이뤄지는 인터페이스 GUI (Graphic User Interface) 아이콘이나 메뉴를 마우스로 선택하여 작업 수행하는 그래픽 환경 NUI (Natural User Interface) 사용자의 말이나 행동으로 기기를 조작하는 인터페이스 사용자 인터페이스의 기본 원칙 [ 직학효연 ] 직관성 : 누구나 쉽게 이해 학습성 : 누구나 쉽게 배우고 익힘 유효성 : 사용자의 목적을 정확하고 완벽하게 달성 유연성 : 사용자의 요구 사항을 최대한 수용, 실수 최소화 사용자 인터페이스의 설계 지침 [ 사일명가 단오 접결표 ] 사용자 중심, 일관성, 명확성, 가시성, 단순성, 오류 발생 해결, 접근성, 결과 예측 가능성, 표준화 사용자 인터페이스 개발 시스템의 기능 사용자의 입력을 검증할 수 있어야함 에러 처리와 그와 관련된 에러 메세지를 표시할 수 있어야함. 도움과 프롬프트(prompt)를 제공해야함. 소프트웨어 패키징의 형상 관리 (SCM) 형상관리 (SCM)는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동 소프트웨어 변경의 원인을 알아내고 제어, 담당자에게 확인하여 통보 소프트웨어 개발 전단계에 적영되는 활동, 유지보수 단계에서도 수행 전체 개발 비용을 줄이고, 개발 과정의 여러 방해 요인 최소화 되도록 보증 프로젝트 계획, 분석서, 설계서, 프로그램 테스트 케이스 포함 형상관리 (SCM)의 중요성 지속적인 소프트웨어의 변경 사항을 체계적으로 추적, 통제 무절제 변경 방지, 버그나 수정 사항을 추적 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준 배포본을 효율적으로 관리 여러 명의 개발자가 동시에 개발 가능 형상 관리 기능 형상 식별 이름과 관리 번호 부여, 계층(Tree) 구조로 구분하여 수정 및 추적 용이 버전 제어 특정 절차와 도구(Tool)를 결합 형상 통제 (변경 관리) 변경 요구 검토 기준선(Base Line)이 잘 반영되도록 조정 형상 감사 무결성 평가를 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인 형상 기록 (상태 보고) 형상의 식별, 통제, 감사 작업의 결과를 기록 관리하고 보고서 작성 소프트웨어의 버전 등록 관련 주요 기능 체크 아웃(check-out) 프로그램을 수정하기 위해 저장소에서 파일을 받아옴 소스 파일과 함께 버전 관리를 위한 파일 받아옴 체크 인(check-in) 새로운 버전으로 갱신 커밋 (commit) 충돌을 알리고 diff도구를 이용해 수정한 후 갱신을 완료 소프트웨어 버전 관리 도구 분산 저장소 방식 개발자 별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영(버전관리)한 다음 이를 원격 저장소에 반영한다. 종류에는 Git, GNU arch, DCVS, Bazaar, Mercurial, Team Ware, Bitkeeper, Plastic SCM Git(깃) 분산 버전 관리 시스템으로 2개의 저장소, 지역(로컬) 저장소와 원격 저장소가 존재 지역 저장소는 개발자들이 실제 개발하는 장소로 버전관리 수행 원격 저장소는 여러 사람들의 협업을 위해 버전을 공동 관리하는 곳 원격 저장소나 네트워크에 문제가 있어도 작업 가능 파일의 변화를 스냅샷으로 저장, 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악함 Add 스테이징 영역 추가 Commit 지역 저장소에 저장 Branch 브랜치 생성 Checkout 지정한 브랜치로 이동","link":"/2023/07/08/2023/07/1%EA%B3%BC%EB%AA%A9-3%EC%9E%A5-%E2%91%A1/"},{"title":"JAVA-연산자-① 정의, 종류, 우선 순위","text":"연산자 정의 연산 프로그램에서 데이터를 처리하여 결과를 산출하는 것 연산자 산술, 부호, 문자열, 대입, 증감, 비교, 논리, 조건 등의 연산을 하는 데에 사용되는 표시나 기호 피연산자 연산 시에 연산이 되어지는 대상 예시 A + B 의 식에서 A, B 변수가 피연산자 연산식 ( = 표현식 ) 연산자와 피연산자를 통해 각 변수 또는 상수가 연산을 하는 식 연산자의 종류 피연산자 개수로 연산자 분류 단항 연산자 : ++, —, !, ^ 등 이항 연산자 : +, -, *, / 삼항 연산자 : (조건식) ? A : B 보통 대부분의 연산자는 이항 연산자다. 연산자 우선 순위 연산식에 사용된 연산자가 둘 이상일 경우, 연산자의 우선 순위에 의해 연산 순서가 결정된다. 단항 연산자(ex. ++,— 등)가 이항 연산자(ex. +,- 등)보다 우선 순위가 높다. 단항 &gt; 이항 &gt; 삼항 산술 &gt; 비교 &gt; 논리 &gt; 대입 우선 순위가 확실하지 않다면, 괄호 ()를 이용하여 묶어주어야 한다. 괄호 안의 계산식이 우선 순위가 제일 높다. 연산자의 결합 규칙은 왼쪽에서 오른쪽 순서이지만, **대입 연산자 (제일 늦음)**는 오른쪽에서 왼쪽으로 진행된다. 예시 1234567891011// 연산자 결합 규칙int a = 10 * 10 * 10;// 순서 : 왼쪽에서 오른쪽a = (10 * 10) * 10 = 100 * 10 = 1000// 대입 연산자 결합 규칙a = b = c = 10;// 순서 : 오른쪽에서 왼쪽c = 10b = ca = b","link":"/2023/07/04/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A0%20%EC%A0%95%EC%9D%98,%20%EC%A2%85%EB%A5%98,%20%EC%9A%B0%EC%84%A0%20%EC%88%9C%EC%9C%84/"},{"title":"JAVA-연산자-② 산술, 부호, 문자열, 대입","text":"산술 연산자 가장 기본이 되는 연산자로 **4칙 연산( +, -, *, /)**과 나머지 값을 구하는 **나머지 연산자(%)**가 있다. 연산자 기호 설명 + 두 수에 대한 덧셈 - 두 수에 대한 뺄셈 * 두 수에 대한 곱셈 / 두 수에 대한 나눗셈 % 두 수를 나눈 후 나머지를 반환 예시 1234567891011int a = 10;System.out.println(&quot;a + 5 = &quot; + (a + 5));// 10 + 5 =&gt; 15System.out.println(&quot;a - 5 = &quot; + (a - 5));// 10 - 5 =&gt; 5System.out.println(&quot;a * 5 = &quot; + (a * 5));// 10 * 5 =&gt; 50System.out.println(&quot;a / 5 = &quot; + (a / 5));// 10 / 5 =&gt; 2System.out.println(&quot;a % 5 = &quot; + (a % 5));// 10 % 5 =&gt; 나머지는 0 결과 부호 연산자 단항 연산자로 양수/음수를 표현하고 값의 부호를 결정 연산자 기호 설명 + 변수에 +1을 곱함 - 변수에 -1을 곱함 예시 12345678910111213int a = 10;System.out.println(&quot;+a = &quot; + (+a));// a 변수값 그대로 출력System.out.println(&quot;-a = &quot; + (-a));// a 변수값을 음수로 변환하여 출력System.out.println(&quot;----------&quot;);int b = -a; // 의도 : a 변수값을 음수로 변환하여 대입System.out.println(&quot;b = &quot; + b);int c = +b; // 의도 : b 변수값을 양수로 변환하여 대입System.out.println(&quot;c = &quot; + c);int d = -b; // 의도 : b 변수값을 음수로 변환하여 대입System.out.println(&quot;d = &quot; + d); 결과 +a와 -a는 의도대로 출력이 된다. 그러나 변환하여 대입할 때 변수 b와 달리 변수 c와 변수 d는 생각과 다르게 표시되는 것을 볼 수 있다. 풀어서 쓰면 c = +(-10) ⇒ c = -10 // d = -(-10) ⇒ d = 10 와 같이 볼 수 있다. 결론 부호 연산자는 단순하게 +, -로 변환하는 것이 아닌 +1, -1를 곱하여 부호를 변환하는 것이라고 볼 수 있다. 문자열 연산자 이항 연산자이며 두 개의 피연산자 중 하나가 문자열인 경우 문자열로 결합한다. 예시 123System.out.println(1 + 1); // 숫자 1 + 숫자 1 = 2System.out.println(&quot;1&quot; + 1); // 문자열 &quot;1&quot; + 숫자 1 = &quot;1&quot;1System.out.println(&quot;1&quot; + &quot;2&quot;); // 문자열 &quot;1&quot; + 문자열 &quot;2&quot; = &quot;1&quot;&quot;2&quot; 결과 1+1의 연산은 문자열이 없어 산술 계산 한 쪽이 문자열이 있는 경우 다른 쪽의 피연산자가 정수여도 문자열로 결합 대입 연산자 오른쪽에 있는 값을 왼쪽 변수에 대입한다. 연산자 기호 설명 = 오른쪽 값을 왼쪽 변수에 대입 += 왼쪽 변수의 값을 오른쪽 변수로 덧셈 후 왼쪽 변수에 대입 -= 왼쪽 변수의 값을 오른쪽 변수로 뺄셈 후 왼쪽 변수에 대입 *= 왼쪽 변수의 값을 오른쪽 변수로 곱셈 후 왼쪽 변수에 대입 /= 왼쪽 변수의 값을 오른쪽 변수로 나눈 후 왼쪽 변수에 대입 %= 왼쪽 변수의 값을 오른쪽 변수로 나눈 후 나머지 값을 왼쪽 변수에 대입 예시 123456789101112131415161718int a = 10;System.out.println(&quot;a = 10 =&gt; a = &quot; + a);a += 5;System.out.println(&quot;10 += 5 =&gt; a = &quot; + a);// a = 10 + 5a -= 5;System.out.println(&quot;15 -= 5 =&gt; a = &quot; + a);// a = 15 - 5a *= 5;System.out.println(&quot;10 *= 5 =&gt; a = &quot; + a);// a = 10 * 5a /= 5;System.out.println(&quot;50 /= 5 =&gt; a = &quot; + a);// a = 50 / 5a %= 5;System.out.println(&quot;10 %= 5 =&gt; a = &quot; + a);// a = 10 % 5 - 나머지 0 결과","link":"/2023/07/05/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A1%20%EC%82%B0%EC%88%A0,%20%EB%B6%80%ED%98%B8,%20%EB%AC%B8%EC%9E%90%EC%97%B4,%20%EB%8C%80%EC%9E%85/"},{"title":"JAVA-연산자-③ 증감, 관계(비교)","text":"증감 연산자 변수의 값을 1 증가 또는 감소시키는 연산자 연산자 기호 설명 ++ 1 증가 – 1 감소 예시 1234567891011121314int a = 10;System.out.println(&quot;a = &quot; + a);// a = a + 1; 와 같음a++;System.out.println(&quot;a++ =&gt; &quot; + a);++a;System.out.println(&quot;++a =&gt; &quot; + a);// a = a - 1; 와 같음a--;System.out.println(&quot;a-- =&gt; &quot; + a);--a;System.out.println(&quot;--a =&gt; &quot; + a); 결과 주의 : 증감 연산자 위치에 따른 차이가 있어서 순서가 중요가 중요하다. ++a/—a 인 경우 증감하여 계산 후, 다른 연산자와 계산 a++/a— 인 경우 다른 연산자와 계산 후, 증감하여 계산 예시 1234567891011// 증감 먼저 계산 후 다른 연산자와 계산int b = 9;int c = ++b * 10;System.out.println(&quot;b = &quot; + b);System.out.println(&quot;++b * 10 = &quot; + c);// 다른 연산자와 계산 후 다른 연산자와 계산int d = 9;int e = d++ * 10;System.out.println(&quot;d = &quot; + d);System.out.println(&quot;d++ * 10 = &quot; + e); 결과 관계(비교) 연산자 2개의 값의 관계를 비교하여 true, false를 판별한다. 크기 비교 연산자 기호 설명 &gt; 좌측 값이 우측 값보다 크면 true, 아니면 false &gt;= 좌측 값이 우측 값보다 크거나 같으면 true, 아니면 false &lt; 좌측 값이 우측 값보다 작으면 true, 아니면 false &lt;= 좌측 값이 우측 값보다 작거나 같으면 true, 아니면 false 예시 123456789101112131415System.out.println(&quot;3 &gt; 2 = &quot; + (3&gt;2));System.out.println(&quot;3 &gt; 3 = &quot; + (3&gt;3));System.out.println(&quot;2 &gt; 3 = &quot; + (2&gt;3));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &gt;= 2 = &quot; + (3&gt;=2));System.out.println(&quot;2 &gt;= 2 = &quot; + (2&gt;=2));System.out.println(&quot;1 &gt;= 2 = &quot; + (1&gt;=2));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &lt; 2 = &quot; + (3&lt;2));System.out.println(&quot;3 &lt; 3 = &quot; + (3&lt;3));System.out.println(&quot;2 &lt; 3 = &quot; + (2&lt;3));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &lt;= 2 = &quot; + (3&lt;=2));System.out.println(&quot;2 &lt;= 2 = &quot; + (2&lt;=2));System.out.println(&quot;1 &lt;= 2 = &quot; + (1&lt;=2)); 결과 동등 비교 연산자 기호 설명 == 좌측 값과 우측 값이 같으면 true, 아니면 false != 좌측 값과 우측 값이 다르면 true, 아니면 false 예시 12345System.out.println(&quot;1 == 1 = &quot; + (1==1));System.out.println(&quot;1 == 2 = &quot; + (1==2));System.out.println(&quot;-------------&quot;);System.out.println(&quot;1 != 1 = &quot; + (1!=1));System.out.println(&quot;1 != 2 = &quot; + (1!=2)); 결과 주의 사항 문자 비교시 아스키 코드에 기반하여 비교를 한다. 참고 : 아스키 코드(ASCII) 예시 123456789101112char a = 'A';char b = 'B';// A &gt; B 일 때, false 출력System.out.println(&quot;A &gt; B = &quot; + (a&gt;b));// 간단하게 A와 B의 차이 출력 =&gt; -1이 출력되어 1의 차이인 것을 확인 할 수 있다System.out.println(a-b);// 정수형으로 형변환 하여 출력 =&gt; A = 65, B = 66인 것을 알 수 있다.int c = (int)a;int d = (int)b;System.out.println(&quot;A = &quot; + c);System.out.println(&quot;B = &quot; + d); 결과","link":"/2023/07/10/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A2%20%EC%A6%9D%EA%B0%90,%20%EA%B4%80%EA%B3%84(%EB%B9%84%EA%B5%90)/"},{"title":"JAVA-연산자-④ 논리, 조건","text":"논리 연산자 2개의 boolean 값의 관계를 비교하여 true, false를 판별한다. boolean : 데이터타입 - boolean(논리형) 연산식 예시 123456789101112131415161718192021222324252627282930boolean a = true;boolean b = false;System.out.println(&quot;true &amp; true = &quot; + (a &amp; a));System.out.println(&quot;true &amp; false = &quot; + (a &amp; b));System.out.println(&quot;false &amp; true = &quot; + (b &amp; a));System.out.println(&quot;false &amp; false = &quot; + (b &amp; b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true &amp;&amp; true = &quot; + (a &amp;&amp; a));System.out.println(&quot;true &amp;&amp; false = &quot; + (a &amp;&amp; b));System.out.println(&quot;false &amp;&amp; true = &quot; + (b &amp;&amp; a));System.out.println(&quot;false &amp;&amp; false = &quot; + (b &amp;&amp; b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true | true = &quot; + (a | a));System.out.println(&quot;true | false = &quot; + (a | b));System.out.println(&quot;false | true = &quot; + (b | a));System.out.println(&quot;false | false = &quot; + (b | b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true || true = &quot; + (a || a));System.out.println(&quot;true || false = &quot; + (a || b));System.out.println(&quot;false || true = &quot; + (b || a));System.out.println(&quot;false || false = &quot; + (b || b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true ^ true = &quot; + (a ^ a));System.out.println(&quot;true ^ false = &quot; + (a ^ b));System.out.println(&quot;false ^ true = &quot; + (b ^ a));System.out.println(&quot;false ^ false = &quot; + (b ^ b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;!true = &quot; + !a);System.out.println(&quot;!false = &quot; + !b); 결과 조건 연산자 조건식, true인 경우의 값, false인 경우의 값을 필요로 하여 총 3개의 피연산자가 있는 연산자다. 1조건식 ? true : false 예시 123456789101112131415161718192021222324252627// a는 5라고 정의int a = 5;String b = a % 2 == 0 ? &quot;짝수&quot; : &quot;홀수&quot;;System.out.println(&quot;a는 &quot; + b + &quot;다&quot;);boolean c = a &gt; 3 ? true : false;System.out.println(&quot;a는 3보다 크다. : &quot; + c);// 조건식을 중첩으로 사용할 수도 있다.String d = a % 2 == 0 ? &quot;짝수&quot; : (a % 2 == 1 ? &quot;홀&quot; : &quot;수&quot;); System.out.println(d);// 조건식을 조건문인 IF문으로 변환하여 사용 가능하다.// IF문에서 경우 조건식으로 바꾸어서 사용할 수 도 있다.boolean e;if (a&gt;3) { e = true;} else { e = false;}System.out.println(&quot;a는 3보다 크다. : &quot; + e);// 피연산자의 타입이 다른 경우 자동 타입 변환이 이루어진다.// a가 5보다 큰 경우 1.0 / 아닌경우 0 이지만 변수 f에 0.0이 대입된다.double f = a &gt; 5 ? 1.0 : 0;System.out.println(f); 결과","link":"/2023/07/11/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A3%20%EB%85%BC%EB%A6%AC,%20%EC%A1%B0%EA%B1%B4/"},{"title":"JAVA-조건문-IF문","text":"조건문 프로그램 흐름에 원하는 기준을 조건으로 분기를 추가하여 흐름을 제어할 때 이용한다. 종류 : if 문, if ~ else 문, if ~ else if ~ else 문, 중첩 if문, switch - case 문 블럭 { } 중괄호로 표현하며, 여러 코드들을 하나로 묶어 블럭처럼 만들어 준다. IF 문 조건식이 참(true)인 경우, 실행문을 실행한다. 조건식이 거짓(false)인 경우, 실행문을 실행하지 않는다. 사용 형식 ①1234567if( 조건식 ) { // 조건식이 참인 경우 실행되는 코드 실행문; 실행문; 실행문; ...} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 예시 1234567int a = 1;if (a &gt; 0) { System.out.println(&quot;a는 0이 아니다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 1이다.&quot;);} 결과 사용 형식 ②1234567// 두가지 형식으로 사용 가능하다.// 1if( 조건식 ) 실행문;// 2if( 조건식 ) 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 예시 123456int a = 1;if(a &gt; 0) System.out.println(&quot;a=1&quot;);if(a &gt; 0) System.out.println(&quot;a=1&quot;); 결과 IF ~ else 문 조건식에 대해 참(true)이 아닌 경우에 실행할 코드들을 추가할 때 이용 조건식이 참(true)인 경우, else 앞의 { } 에서 실행문을 실행한다. 조건식이 거짓(false)인 경우, else 뒤의 { } 에서 실행문을 실행한다. 사용 형식 ①123456789if ( 조건식 ) { // 조건식이 참인 경우 실행되는 코드 실행문; 실행문;} else { // 조건식이 거짓인 경우 실행되는 코드 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 예시 123456789int a = 0;if (a &gt; 0) { System.out.println(&quot;a는 0이 아니다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 1이다.&quot;);} else { System.out.println(&quot;a는 0보다 크지 않다.&quot;); System.out.println(&quot;a는 0일 수 있다.&quot;);} 결과 사용 형식 ②12if ( 조건식 ) 실행문;else 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 예시 1234int a = 0; if (a &gt; 0) System.out.println(&quot;a는 0보다 크다.&quot;); else System.out.println(&quot;a는 0보다 크지 않다.&quot;); 결과 IF ~ else if ~ else 문 앞서 이용했던 IF ~ else 문에서 조건식을 추가하여 조금 더 다양하게 분기를 나누고 싶을 때는 IF ~ else if ~ else 문을 이용한다. 조건식 ① 에서 참인 경우 실행문 ① 실행, 거짓인 경우 조건식 ② 에서 참, 거짓을 구분한다. 조건식 ② 에서 참인 경우 실행문 ② 실행, 거짓인 경우 실행문 ③ 을 실행한다. 사용 형식 ①12345678910111213if ( 조건식 ① ) { // 조건식 ① 이 참인 경우 실행되는 코드 실행문; 실행문;} else if( 조건식 ② ) { // 조건식 ① 이 거짓, 조건식 ② 가 참인 경우 실행되는 코드 실행문; 실행문;} else { // 조건식 ① 과 ② 가 참인 경우 실행되는 코드 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 예시 1234567891011int a = 0;if (a &gt; 0) { System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;);} else if ( a == 0 ){ System.out.println(&quot;a는 0이다.&quot;); System.out.println(&quot;a는 0이다.&quot;);} else { System.out.println(&quot;a는 0보다 작다.&quot;); System.out.println(&quot;a는 0보다 작다.&quot;);} 결과 사용 형식 ②123if ( 조건식 ① ) 실행문①;else if( 조건식 ② ) 실행문②;else 실행문③; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 예시 1234int a = 0;if (a &gt; 0) System.out.println(&quot;a는 0보다 크다.&quot;); else if(a == 0) System.out.println(&quot;a는 0이다.&quot;);else System.out.println(&quot;0는 0보다 작다.&quot;); 결과 중첩 IF 문 횟수 제한 없이 IF문을 중첩하여 사용할 수 있다. 사용하는 IF문들 안에서 분기를 나누고 싶을 때 사용한다. 사용 형식1234567891011121314151617181920if ( 조건식 ① ) { // 조건식 ① 이 참인 경우 실행되는 코드 실행문; if ( 조건식 ② ) { // 조건식 ② 이 참인 경우 실행되는 코드 실행문; } else if ( 조건식 ③ ) { // 조건식 ② 이 거짓, 조건식 ③ 이 참인 경우 실행되는 코드 실행문; } else { // 조건식 ② 와 ③ 이 거짓인 경우 실행되는 코드 실행문; }} else if( 조건식 ④ ) { // 조건식 ① 이 거짓, 조건식 ④ 가 참인 경우 실행되는 코드 실행문;} else { // 조건식 ① 과 ④ 가 거짓인 경우 실행되는 코드 실행문;} 예시 123456789101112131415161718int a = 1;if (a &gt; 0) { System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); if (a == 1) { System.out.println(&quot;a == 1&quot;); } else if (a == 2) { System.out.println(&quot;a == 2&quot;); } else { System.out.println(&quot;a == ??&quot;); }} else if ( a == 0 ){ System.out.println(&quot;a는 0이다.&quot;); System.out.println(&quot;a는 0이다.&quot;);} else { System.out.println(&quot;a는 0보다 작다.&quot;); System.out.println(&quot;a는 0보다 작다.&quot;);} 결과","link":"/2023/07/12/2023/07/JAVA-%EC%A1%B0%EA%B1%B4%EB%AC%B8-IF%EB%AC%B8/"},{"title":"JAVA-조건문-Switch~Case문","text":"조건문 프로그램 흐름에 원하는 기준을 조건으로 분기를 추가하여 흐름을 제어할 때 이용한다. 종류 : if 문, if ~ else 문, if ~ else if ~ else 문, 중첩 if문, switch - case 문 Switch ~ Case 문 IF 문과 같은 조건문이지만 다양한 연산자들을 이용하여 조건식을 만들 수 있는 IF 문과 달리 특정 값일 때에 실행문을 실행한다. 사용 형식12345678910switch(변수) { case 값1: 실행문; break; case 값2: 실행문; break; default: 실행문;} Switch ~ Case 문은 Switch 문 에 들어가는 변수를 Case 문 에서 조건을 만들어 특정 값을 지정하면 break 문 전까지 실행문을 실행한다. 만약 모든 Case 문의 조건에 충족되지 않는다면 default의 실행문을 실행하게 된다. 예시 12345678910111213int a = 1;switch (a) { case 1: System.out.println(&quot;1&quot;); System.out.println(&quot;1&quot;); break; case 2: { System.out.println(&quot;2&quot;); break; } default: System.out.println(&quot;default&quot;);} 결과 IF 문과 달리 Case 문에서 블록기호 { } 를 사용하지 않아도 두 줄이상 사용이 가능하다. 참고 : depra3’s JAVA-조건문-IF문 ※ 주의 사항 ※ Case 문 처리 이후 break 문으로 마무리 지어야 한다. 그렇지 않으면 break 문이 나올 때 까지 모든 Case문을 처리한다. 만약 모든 Case 문에 break 문이 없다면, default 문의 실행문 까지 실행한다. 예시 1234567891011int a = 1;switch (a) { case 1: System.out.println(&quot;1&quot;); System.out.println(&quot;1&quot;); case 2: { System.out.println(&quot;2&quot;); } default: System.out.println(&quot;default&quot;);} 결과","link":"/2023/07/14/2023/07/JAVA-%EC%A1%B0%EA%B1%B4%EB%AC%B8-Switch~Case%EB%AC%B8/"},{"title":"JAVA-반복문-while문","text":"반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문이다. 종류 : while 문, do ~ while 문, for 문 while 문 while 문은 조건식이 참(true) 인 경우에 동작하는 반복문이며, 거짓(false)이라면 반복하지 않고 while 문에서 빠져나와 그 다음 코드를 실행한다. 사용 형식 ①1234while(조건식){ 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 예시 12345int a = 1;while (a &lt;= 10) { System.out.println(&quot;a = &quot; + a); a++;} 결과 사용 형식 ②12while(조건식) 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 실행문이 두 줄인 경우, 첫 줄만 반복한다. 사용 빈도가 매우 낮다. 예시 123int b = 1;while (b &lt;= 10) System.out.println(&quot;b = &quot; + b++); 결과","link":"/2023/07/15/2023/07/JAVA-%EB%B0%98%EB%B3%B5%EB%AC%B8-while%EB%AC%B8/"}],"tags":[{"name":"JAVA EE","slug":"JAVA-EE","link":"/tags/JAVA-EE/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"JAVA Spring","slug":"JAVA-Spring","link":"/tags/JAVA-Spring/"},{"name":"Apache Tomcat","slug":"Apache-Tomcat","link":"/tags/Apache-Tomcat/"},{"name":"JAVA SE","slug":"JAVA-SE","link":"/tags/JAVA-SE/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"정보처리 산업기사","slug":"정보처리-산업기사","link":"/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC-%EC%82%B0%EC%97%85%EA%B8%B0%EC%82%AC/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"}],"categories":[{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"Utile","slug":"Utile","link":"/categories/Utile/"},{"name":"자격증 참고 자료","slug":"자격증-참고-자료","link":"/categories/%EC%9E%90%EA%B2%A9%EC%A6%9D-%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C/"}],"pages":[]}