{"posts":[{"title":"JAVA Spring Boot(STS - Spring Tools 4) 설치","text":"JAVA Spring Boot를 사용하기 위한 준비 Eclipse EE version은 2022-09(4.25.0) 설치 방법 링크 : JAVA EE &amp; Apche Tomcat 설치 Help → Eclipse Marketplace… 클릭 (잠시 동안 로딩이 있을 수 있습니다.) sts 검색 → 최신 버전(현재는 Spring Tools 4가 최신) 찾기 → Install 클릭 Confirm 클릭 약 2~3분 정도 소요됩니다. ① 동그라미 체크 → ② Finish 클릭 붉은 박스 클릭하면 현재 진행도가 상세하게 나옵니다. 설치 중간에 갑자기 Trust 창이 뜹니다. ① Select All 클릭 → ② Trust Selected 클릭 Restart Now 클릭 Eclipse가 다시 시작되니 잠시 기다려봅시다. ☆ TEST ☆ File 클릭 → New에 마우스 커서 놓기 → Other.. 클릭 ① spring 입력 (자동 검색) → ② Spring Starter Project 클릭 → ③ Next 클릭 ① Project 이름 / ② Gradle - Groovy로 설정 / ③ 클릭하여 8로 설정 / ④ 클릭하여 War로 설정 (글쓴이가 배운 설정입니다.) 설정 후 확인 ① spring web 입력 → ② 네모박스 체크 → ③ 선택되었는지 확인 → ④ Finish 클릭 그림과 같은 구조로 생성되는 것을 확인할 수 있습니다. 간혹 유효성 관련한 창이 뜨기도 하는데 검색해보니 검색을 잘 못하는 건지 찾기가 힘듭니다.아무거나 클릭해도 무방할 듯 싶습니다.","link":"/2023/01/07/2023/01/JAVA_Spring_Boot_(STS-Spring_Tools_4)_Install/"},{"title":"정보처리 산업기사(2023) 1과목-2장-②","text":"정보 시스템 기반 기술HIPO (Hierarchy Input Process Output) 시스템의 분석 및 설계나 문서화할 때 사용되는 기법, 시스템 실행 과정인 입력, 처리, 출력의 기능을 나타낸다. 하향식 기법 기본 시스템 모델은 입력, 처리, 출력으로 구성, 하향식 소프트웨어 개발을 위한 문서화 도구 체계적인 문서 관리 기능 기호, 도표 등 사용으로 이해가 쉬움 변경, 유지 보수 용이 가시적 도표 (VTC), 총체적 도표 (OD), 세부적 도표 (DD) HIPO Chart의 종류 가시적 도표(도식 목차) 시스템 전체적인 기능과 흐름을 보여주는 계층(Tree) 구조도 총체적 도표(총괄도표, 개요도표) 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공하는 도표 세부적 도표(상세 도표) 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표 UML [ 사관다 ] 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통을 위한 객체 지향 모델링 언어 사물 (Things), 관계(Relationship), 다이어그램(Diagram) 다이어그램 사물과 관계를 도형으로 표현한 것 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움 정적 모델링에서는 주로 구조적 다이어그램을 사용, 동적 모델링에서는 주로 행위 다이어그램을 사용 구조 다이어그램 클래스 다이어그램 : 클래스의 구조, 속성, 메서드, 관계 등을 보여줍니다. 시스템의 구조를 파악하고 구조상의 문제점을 도출 객체 다이어그램 : 객체 간의 관계, 객체의 속성, 상태 등을 보여줍니다. 람바우 객체지향 분석 기법에서 객체 모델링에 활용 컴포넌트 다이어그램 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현 구현 단계에서 사용되는 다이어그램 패키지 다이어그램 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현 복합체 구조 다이어그램 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현 배치 다이어그램 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현 노드와 의사소통(통신) 경로로 표현 구현 단계에서 사용되는 다이어그램 행위 다이어그램 유즈케이스 다이어그램 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용한다. 사용자와 사용 사례로 구성되며 사용 사례 간에는 여러 형태의 관계로 이루진다. 상태 다이어그램 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현 럼바우 객체지향 분석 기법에서 동적 모델링에 활용 시퀀스 다이어그램 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현 구성 요소 활동 다이어그램 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현 커뮤니케이션 다이어그램 시퀀스 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데 메시지뿐만 아니라 객체들간의 연관까지 표현 상호작용 개요 다이어그램 상호작용 다이어그램 간의 제어 흐름을 표현 타이밍 다이어그램 객체 상태 변화와 시간 제약을 명시적으로 표현 소프트웨어 아키텍처의 설계 소프트웨어의 골격이 되는 기본 구조, 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체 소프트웨어 개발 시 적용되는 원칙과 지침이며 이해 관계자들의 의사소통 도구로 활용 기본 원리로는 모듈화, 추상화, 단계적 분해, 정보은닉이 있음 설계 단계는 크게 상위 설계와 하위 설계로 구분 협약에 의한 설계 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것으로 소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세한다. 협약에 의한 설계 시 명세에 포함될 조건에는 선행 조건, 결과 조건, 불변 조건이 있다.","link":"/2023/07/01/2023/07/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A1/"},{"title":"정보처리 산업기사(2023) 1과목-2장-③","text":"1과목-2장-③아키텍처 패턴 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴 아키텍처 스타일 또는 표준 아키텍처 장점 시행착오를 줄여 개발 시간을 단축시키고 고품질의 소프트웨어를 생산할 수 있다. 검증된 구조로 개발하기 때문에 안정적인 개발이 가능하다. 이해관계자들이 공통된 아키텍처를 공유할 수 있어 의사소통이 간편해진다. 시스템 구조를 이해하는 것이 쉬워 개발에 참여하지 않은 사람도 손쉽게 유지보수를 수행할 수 있다. 시스템의 특성을 개발 전에 예측하는 것이 가능 레이어 패턴 시스템을 계층으로 구분하여 구성하는 고전적인 방법 중의 하나 레이어 패턴은 각각의 서브시스템들이 계층 구조를 이루며 상위 계층은 하위 계층에 대한 서비스 제공자가 되고, 하위 계층은 상위 계층의 클라이언트가 된다. 레이어 패턴은 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어지며 변경 사항을 적용할 때도 서로 마주보는 두 개의 계층에만 영향을 미치므로 변경 작업이 용이하다. 레이어 패턴은 특정 계층만을 교체해 시스템을 개선하는 것이 가능하다. 대표적으로 OSI 참조 모델이 있다. 장단점 장점 : 정보 은닉의 원칙 적용 → 높은 이식성 단점 : 추가적인 실행시 오버헤드(너무 많은 계층으로 성능 감소 발생) 클라이언트 - 서버 패턴 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴이다. 클라이언트-서버 패턴에서 사용자는 클라이언트와만 의사소통을 한다. 즉, 사용자가 클라이언트를 통해 서버에 요청하고 클라이언트가 응답을 받아 사용자에게 제공하는 방식으로 서비스를 제공한다. 서버는 클라이언트의 요청에 대비해 항상 대기 상태를 유지해야 한다. 클라이언트나 서버는 요청과 응답을 받기 위해 동기화되는 경우를 제외하고는 서로 독립적이다. 장단점 장점 : 직접적으로 데이터 분산, 위치 투명성 제공 단점 : 서비스와 서버의 이름을 관리하는 레지스터 부재로 이용 가능 서비스 탐색 불편 파이프-필터 패턴 (Pipe-Filter-Pattern) 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴 필터 컴포넌트는 재사용성이 좋고 추가가 쉬워 확장에 용이함 필터 컴포넌트들을 재배치하여 다양한 파이프라인을 구축하는 것이 가능 변환, 버퍼링, 동기화에 주로 사용 필터 간 데이터 이동 시 데이터 변환으로 인한 오버헤드가 생김 대표적으로 UNIX의 쉘 장단점 장점 : 필터 교환과 재조합을 통한 높은 유연성 제공 단점 : 상태 정보 공유를 위한 고비 용과 데이터 변환 과부화 모델 - 뷰 - 컨트롤러 패턴 서브시스템을 3개의 부분으로 구조화하는 패턴이다. 모델(Model): 서브시스템의 핵심 기능과 데이터를 보관한다. 뷰(View): 사용자에게 정보를 표시한다. 컨트롤러(Controller): 사용자로부터 받은 입력을 처리한다. 장단점 장점 : 동일한 모델, 다양한 뷰 제공 및 뷰 동기화로 실시간 변경 데이터 제공 단점 : 단순 어플리케이션은 복잡성증가 모델-뷰-컨트롤러 패턴의 각 부분은 별도의 컴포넌트로 분리되어 있으므로 서로 영향을 받지 않고 개발 작업을 수행할 수 있다. 모델-뷰-컨트롤러 패턴에서는 여러 개의 뷰를 만들 수 있으므로 한 개의 모델에 대해 여러 개의 뷰를 필요로하는 대화형 애플리케이션에 적합하다. 기타 패턴 PTP 장점 : 분산컴퓨팅 어플 구축시 유연성 제공 블랙보드 장단점 장점 : 다양한 접근법, 유지보수성,가변성,재사용 가능한 지식자원 단점 : 테스팅 어려움, 완전한 해결책 미보장 브로커 장단점 장점 : 위치 투명성, 연동 용이, 재사용 컴포넌트 확보 용이 단점 : 성능 불이익, 장애 대처 어려움, 디버깅 어려움 객체 지향 설계 원칙 = SOLID 원칙 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙 객체 지향 [ 객클메 ] , [ 정관다 캡상추 ] 참고 : 객체지향 개발방법론 - 해시넷 (hash.kr) 객클메 객체, 클래스, 메시지 정관다 캡상추 정보 은닉, 관계성, 다형성, 캡슐화, 상속성, 추상화 연관성 : 두 개 이상의 객체(클래스)들이 상호 참조하는 관계 is part of, is number of, in instance of, is a 객체 지향 분석의 방법론 Rumbaugh (럼바우) 방법 : 일반적으로 사용, 객체 모델, 동적 모델, 기능 모델 나누어 수행 Booch (부치) 방법 : 미시적, 거시적 개발 프로세스를 모두 사용 Jacobson 방법 : Use Case 강조하여 사용 Coad와 Yordon 방법 : E-R 다이어그램 사용 Wirfs - Brock 방법 : 분석과 설계가 없고 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행 Rumbaugh(럼바우) 분석 기법 [ 객동기 ] 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법으로 객체 모델링 기법(OMT) 객체 모델링 ( 객체 다이어그램 표시 ) → 동적 모델링 ( 상태 다이어그램 ) → 기능 모델링 ( 자료 흐름도 - DFD - ) 디자인 패턴 참고 : 디자인 패턴 모듈 간의 인터페이스 코드를 작성하는 수준의 세부적인 구현 방안을 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제 객체 지향 프로그래밍 설계를 할 때 자주 발생하는 문제들을 피하기 위해 사용되는 패턴. 디자인 패턴 사용의 장단점 범용적인 코딩 스타일로 인해 구조 파악이 용이하다. 객체 지향 설계 및 구현의 생산성을 높이는 데 적합하다. 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약된다. 초기 투자 비용이 부담될 수 있다. 개발자 간의 원활한 의사소통이 가능하다. 설계 변경 요청에 대한 유연한 대체가 가능하다. 객체 지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에는 적합하지 않다. 생성 패턴 (추상 객체 인스턴스화) - [ 추팩 빌팩 프싱 ] 객체의 생성에 관련된 패턴으로 객체의 생성 절차를 추상화하는 패턴 추상 팩토리 패턴, 빌더 패턴, 팩토리 패턴, 프로토타입 패턴, 싱글톤 패턴 구조 패턴 (객체 간 결합) [ 어브컴 데파플프 ] 클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴 어댑터, 브리지, 컴포지트, 데코레이터, 파사드, 플라이웨이트, 프록시 행위 패턴 (객체 간 커뮤니케이션) [ 책커 인반 중메 옵상 전템방 ] 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴 책임 연쇄(체인), 커맨드, 인터프리터, 반복자(이터레이터), 중재자. 메멘토, 옵저버, 상태, 전략, 템플릿 메소드, 방문자","link":"/2023/07/03/2023/07/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A2/"},{"title":"정보처리 산업기사(2023) 1과목-3장-①","text":"정보 시스템 기반 기술3장 테스트 및 배포 화이트 박스 테스트, 블랙박스 테스트, 단위 테스트, 통합 테스트, 하향식 통합 테스트, 상향식 통합 테스트, 결함, 사용자 인터페이스 (UI), 형상 관리, Git 화이트 박스 테스트 모듈의 원시 코드를 오픈 시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방식 절차에 초점을 맞춤, 테스트 과정의 초기에 적용, 모든 모듈 안의 작동을 직접 관찰 원시 코드(모듈)의 모든 문장을 한 번 이상 실행 선택, 반복 등 분기점 부분들을 수행함으로써 논리적 경로 제어 화이트 박스 테스트의 종류 기초 경로 검사 (Base Path Testing) 대표적인 화이트 박스 테스트 기법, 논리적 복잡성 측정, 실행 경로의 기초를 정의하는 데 지침으로 사용 제어 구조 검사 (Control Structure Testing) 조건 검사 (Condition Testing) : 논리적 조건 테스트 루프 검사 (Loop Testing) : 프로그램 반복 구조에 초점을 맞춤 데이터 흐름 검사 (Data Flow Testing) : 변수의 정의와 변수 사용 위치에 초점을 맞춤 블랙 박스 테스트 소프트웨어가 수행할 특정 기능을 알기 위해서 완전히 작동되는 것을 입증하는 테스트 기능 테스트라고도 함 사용자의 요구 명세를 보며 실시하는 테스트 사용자 인터페이스에서 실시 부정확 하거나 누락된 기능, 인터페이스 오류, 자료 구조나 외부 데이터베이스 접근에 따른 오류, 행위나 성능 오류, 초기화와 종료 오류 발견 테스트 과정의 후반부에 적용 블랙 박스 테스트의 종류 동치 분할 검사 = 동등 분할 기법 (Equivalence Partitioning Testing) 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사하는 방법 경계값 분석 (Boundary Value Analysis) 동치 분할 기법을 보완하기 위한 기법 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법이다. 원인 효과 그래프 검사 (Cause-Effect Graphing Testing) 효용성이 높은 테스트 케이스를 선정하여 검사 오류 예측 검사 = 데이터 확인 검사 (Error Guessing) 블랙 박스 테스트 기법으로 찾을 수 없는 오류를 찾아내는 보충적 검사 기법 비교 검사 (Comparison Testing) 여러 버전의 프로그램에 동일한 테스트 자료 제공, 동일한 결과가 출력되는지 테스트 개발 단계에 따른 애플리케이션 테스트 SW 생명 주기 [ 요 설 구 테 유 ] / [ 요-분-설-구 ] / 소프트웨어 개발 단계 요구 사항 분석 → 설계 → 구현 → 테스트 → 유지 보수 테스트 단계 [ 단 통 시 인 ] 단위 테스트 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트 인터페이스, 외부적I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사 구조 기반 테스트 프로그램 내부 구조 및 복잡도를 검증하는 화이트 박스 테스트 실행 목적 : 제어 흐름, 조건 결정 명세 기반 테스트 목적 및 실행 코드 기반의 블랙박스 테스트 실행 목적 : 동등 분할, 경계 값 분석 통합 테스트 ( = 결합 테스트) 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사 점진적 모듈 통합 방법 : 하향식, 상향식 하향식 통합 테스트 ( Top Down Intergration Test ) 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트 하는 기법 주요 제어 모듈의 종속 모듈들은 Stub으로 대체 Stub : 함수 이름만 있거나 내용이 완전치 않은 코드 깊이 우선 (하위 계층 우선) or 넓이 우선(같은 계층 우선) 등의 통합 방식에 따라 하위 모듈인 Stub들이 한번에 하나씩 실제 모듈로 교체 모듈이 통합될 때 마다 테스트 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트 실시 상향식 통합 테스트 ( Bottom Up Intergration Test ) 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트 하는 기법 Cluster가 필요 / Cluster : 하나의 주요 제어 모듈과 관련된 종속 모듈 그룹 하위 모듈들을 Cluster로 결합, 상위 모듈에서 Driver 작성 Driver : 더미 모듈 통합된 Cluster 단위로 테스트 테스트가 완료되면 Cluster프로그램 구조의 상위로 이동하여 결합하고 Driver는 실제 모듈로 대체 장점 : 위치 투명성, 연동 용이, 재사용 컴포넌트 확보 용이 단점 : 성능 불이익, 장애 대처 어려움, 디버깅 어려움 시스템 테스트 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는 가를 점검하는 테스트 환경적인 장애 리스크를 최소화하기 위해서는 실제 사용 환경과 유사하게 만든 테스트 환경에서 테스트를 수행 기능적 요구 사항과 비기능적 요구 사항으로 구분하여 각각을 만족하는지 테스트 기능적 요구 사항 요구 사항 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트 시행 비기능적 요구 사항 성능 테스트, 회복 테스트, 보안 테스트, 내부 시스템의 메뉴 구조, 웹페이지의 네비게이션 등 구조적 요소에 대한 화이트 박스 테스트 시행 인수 테스트 개발한 소프트웨어가 사용자의 요구 사항을 충족하는 지에 중점을 두고 테스트 개발한 소프트웨어를 사용자가 직접 테스트 함 문제가 없으면 사용자는 소프트웨어를 인수 인수 테스트 6 종류 사용자 인수 테스트 사용자가 시스템 사용의 적절성 여부 확인 운영 상의 인수 테스트 시스템 관리자가 백업 / 복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인 계약 인수 테스트 인수 / 검수 조건을 준수하는 여부 확인 규정 인수 테스트 정부 지침, 법규, 규정에 맞게 개발 확인 알파 테스트 개발자의 장소에서 사용자가 개발자 앞에서 하는 테스트 기법 통제된 환경에서 행해지며, 오류와 문제점을 사용자와 개발자가 함께 확인하며 기록 베타 테스트 ( = 필드 테스트) 선정된 사용자가 여러 명의 사용자 앞에서 하는 테스트 기법(필드 테스팅) 실제 업무를 가지고 사용자가 직접 테스트 하는 것 개발자에 의해 제어되지 않는 상태에서 테스트 실행 발견된 오류와 문제점을 기록하고 개발자에게 주기적으로 보고","link":"/2023/07/07/2023/07/1%EA%B3%BC%EB%AA%A9-3%EC%9E%A5-%E2%91%A0/"},{"title":"정보처리 산업기사(2023) 1과목-3장-②","text":"정보 시스템 기반 기술3장 테스트 및 배포 화이트 박스 테스트, 블랙박스 테스트, 단위 테스트, 통합 테스트, 하향식 통합 테스트, 상향식 통합 테스트, 결함, 사용자 인터페이스 (UI), 형상 관리, Git 사용자 인터페이스 (UI) UI는 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어를 의미 UI의 특징 만족도에 가장 큰 영향을 미치며 변경이 가장 많이 발생 사용자의 가독성을 높임으로써 작업 시간 단축 최소한의 노력으로 원하는 결과 나올 수 있도록 한다. 오류를 줄이고 구체적인 방법 제공 사용자가 인터페이스를 설계하기 위해서는 소프트웨어 아키텍처를 반드시 숙지 사용자 인터페이스의 구분 CLI (Command Line Interface) 명령과 출력 테스트 형태로 이뤄지는 인터페이스 GUI (Graphic User Interface) 아이콘이나 메뉴를 마우스로 선택하여 작업 수행하는 그래픽 환경 NUI (Natural User Interface) 사용자의 말이나 행동으로 기기를 조작하는 인터페이스 사용자 인터페이스의 기본 원칙 [ 직학효연 ] 직관성 : 누구나 쉽게 이해 학습성 : 누구나 쉽게 배우고 익힘 유효성 : 사용자의 목적을 정확하고 완벽하게 달성 유연성 : 사용자의 요구 사항을 최대한 수용, 실수 최소화 사용자 인터페이스의 설계 지침 [ 사일명가 단오 접결표 ] 사용자 중심, 일관성, 명확성, 가시성, 단순성, 오류 발생 해결, 접근성, 결과 예측 가능성, 표준화 사용자 인터페이스 개발 시스템의 기능 사용자의 입력을 검증할 수 있어야함 에러 처리와 그와 관련된 에러 메세지를 표시할 수 있어야함. 도움과 프롬프트(prompt)를 제공해야함. 소프트웨어 패키징의 형상 관리 (SCM) 형상관리 (SCM)는 소프트웨어의 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동 소프트웨어 변경의 원인을 알아내고 제어, 담당자에게 확인하여 통보 소프트웨어 개발 전단계에 적영되는 활동, 유지보수 단계에서도 수행 전체 개발 비용을 줄이고, 개발 과정의 여러 방해 요인 최소화 되도록 보증 프로젝트 계획, 분석서, 설계서, 프로그램 테스트 케이스 포함 형상관리 (SCM)의 중요성 지속적인 소프트웨어의 변경 사항을 체계적으로 추적, 통제 무절제 변경 방지, 버그나 수정 사항을 추적 가시성이 결핍되므로 진행 정도를 확인하기 위한 기준 배포본을 효율적으로 관리 여러 명의 개발자가 동시에 개발 가능 형상 관리 기능 형상 식별 이름과 관리 번호 부여, 계층(Tree) 구조로 구분하여 수정 및 추적 용이 버전 제어 특정 절차와 도구(Tool)를 결합 형상 통제 (변경 관리) 변경 요구 검토 기준선(Base Line)이 잘 반영되도록 조정 형상 감사 무결성 평가를 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인 형상 기록 (상태 보고) 형상의 식별, 통제, 감사 작업의 결과를 기록 관리하고 보고서 작성 소프트웨어의 버전 등록 관련 주요 기능 체크 아웃(check-out) 프로그램을 수정하기 위해 저장소에서 파일을 받아옴 소스 파일과 함께 버전 관리를 위한 파일 받아옴 체크 인(check-in) 새로운 버전으로 갱신 커밋 (commit) 충돌을 알리고 diff도구를 이용해 수정한 후 갱신을 완료 소프트웨어 버전 관리 도구 분산 저장소 방식 개발자 별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소에서 우선 반영(버전관리)한 다음 이를 원격 저장소에 반영한다. 종류에는 Git, GNU arch, DCVS, Bazaar, Mercurial, Team Ware, Bitkeeper, Plastic SCM Git(깃) 분산 버전 관리 시스템으로 2개의 저장소, 지역(로컬) 저장소와 원격 저장소가 존재 지역 저장소는 개발자들이 실제 개발하는 장소로 버전관리 수행 원격 저장소는 여러 사람들의 협업을 위해 버전을 공동 관리하는 곳 원격 저장소나 네트워크에 문제가 있어도 작업 가능 파일의 변화를 스냅샷으로 저장, 스냅샷은 이전 스냅샷의 포인터를 가지므로 버전의 흐름을 파악함 Add 스테이징 영역 추가 Commit 지역 저장소에 저장 Branch 브랜치 생성 Checkout 지정한 브랜치로 이동","link":"/2023/07/08/2023/07/1%EA%B3%BC%EB%AA%A9-3%EC%9E%A5-%E2%91%A1/"},{"title":"JAVA-객체","text":"목차 객체 객체의 구성 객체 (Object) 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신과 다른 것을 식별 가능한 것 물리적 사람, 책, 자동차, 컴퓨터 등 추상적 학과, 부서, 종류 등 객체의 구성 속성(property) 자동차의 속성 - 제조사, 모델, 색깔 등 멤버 변수(member variable), 특성(attribute), 필드(field), 상태(state) 기능(function) 자동차의 기능 - 시동, 주행, 정지 등 메서드(method), 함수(function), 행위(behavior) 코드 12345678910111213141516171819202122public class Car { // 속성 - 멤버 변수 public String company; // 제조사 public String model; // 자동차 모델 public String color; // 자동차 색깔 public int maxSpeed; // 최고 속도 public int currentSpeed; // 현재 속도 // 기능 - 메서드 public void speedUp() { this.currentSpeed = this.currentSpeed + 1; } public int speedDown() { this.currentSpeed--; return this.currentSpeed; } public int getCurrentSpeed() { return this.currentSpeed; }}","link":"/2023/07/25/2023/07/JAVA-%EA%B0%9D%EC%B2%B4/"},{"title":"JAVA - 반복문 - do ~ while 문","text":"반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문이다. 종류 : while 문, do ~ while 문, for 문, foreach 문 do ~ while 문 do ~ whilie 문은 { } 안의 실행문을 무조건 한번 실행한 후 조건식에서 참(true) / 거짓(false)을 가려 참(true)인 경우 반복문을 실행하고 거짓(false)인 경우 반복문을 종료한다. 사용 형식 ① 예시 1234do { 실행문;} while (조건식)// 조건식이 참인 경우 반복문 실행, 거짓인 경우 반복문 실행하지 않음. 코드 12345678910111213int a = 1;do { System.out.println(&quot;a = &quot; + a); a++;} while (a==1);System.out.println(&quot;-----&quot;);int b = 1;do { System.out.println(&quot;b = &quot; + b); b++;} while (b &lt; 10); 결과 사용 형식 ② 예시 1234do 실행문;while (조건식)// 조건식이 참인 경우 반복문 실행, 거짓인 경우 반복문 실행하지 않음. 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 실제로 사용하는 것을 본 적 없다. 코드 12345678910int a = 1;do System.out.println(&quot;a = &quot; + a++);while (a==1);System.out.println(&quot;-----&quot;);// 한 줄로 사용할 수도 있다.int b = 1;do System.out.println(&quot;b = &quot; + b++); while (b &lt; 10); 결과","link":"/2023/07/17/2023/07/JAVA-%EB%B0%98%EB%B3%B5%EB%AC%B8-do~while%EB%AC%B8/"},{"title":"JAVA - 반복문 - foreach 문","text":"목차 반복문 foreach 문 사용 형식 반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문이다. 종류 : while 문, do ~ while 문, for 문, foreach 문 foreach 문 자바 1.5버전부터 foreach 기능 추가 초기값, 리스트 or 배열를 앞에 정의하여 사용하는 반복문이다. 리스트 목록을 받아 리스트 목록 개수만큼 반복문 안의 실행문을 실행한다. 사용 형식 예시 1234데이터 타입[] 변수명 ① = { ... };for ( 데이터타입 변수명 ②: 변수명 ①) { System.out.println(변수명 ②);} 코드 1234String[] a = { &quot;일&quot;, &quot;이&quot;, &quot;삼&quot;};for (String str : a) { System.out.println(str);} 결과","link":"/2023/07/21/2023/07/JAVA-%EB%B0%98%EB%B3%B5%EB%AC%B8-foreach%EB%AC%B8/"},{"title":"JAVA-반복문-while문","text":"반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문이다. 종류 : while 문, do ~ while 문, for 문, foreach 문 while 문 while 문은 조건식이 참(true) 인 경우에 동작하는 반복문이며, 거짓(false)이라면 반복하지 않고 while 문에서 빠져나와 그 다음 코드를 실행한다. 사용 형식 ① 예시 1234while(조건식){ 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 코드 12345int a = 1;while (a &lt;= 10) { System.out.println(&quot;a = &quot; + a); a++;} 결과 사용 형식 ② 예시 12while(조건식) 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 실행문이 두 줄인 경우, 첫 줄만 반복한다. 사용 빈도가 매우 낮다. 코드 123int b = 1;while (b &lt;= 10) System.out.println(&quot;b = &quot; + b++); 결과","link":"/2023/07/15/2023/07/JAVA-%EB%B0%98%EB%B3%B5%EB%AC%B8-while%EB%AC%B8/"},{"title":"정보처리 산업기사(2023) 2과목-1장-①","text":"목차 프로그래밍 언어 활용 언어별 데이터 타입 변수명 작성 규칙 연산자 데이터 입출력 프로그래밍 언어 활용 변수, 연산자 scanf, printf, if, for, while, do~while, 배열, 슬라이스(slice) 정수 타입 - 소수점이 없음 / 1, -1, 10, -100 부동 소수점 타입 - 소수점 이하가 있는 실수 문자 타입 - 한 문자를 저장할 때, (’ ’) 작은 따옴표 표시 문자열 타입 - (” ”) 큰 따옴표 표시 불린 타입 - 참, 거짓 판단 default는 False 배열 타입 - 같은 타입의 데이터의 집합, {} 중괄호 안에 ‘,’ 콤마로 구분하여 값을 나열 언어별 데이터 타입 C / C++ JAVA Python 변수명 작성 규칙 영문자, 숫자, _ (under bar)를 사용할 수 있음 첫 글자는 영문자나 _ (under bar), 숫자 안됨 글자 수에 제한 없음 대 소문자 구분함, 끝에는 반드시 세미콜론(;) 예약어를 변수명으로 사용 불가 데이터 타입을 명시하는 것을 헝가리안 표시법 연산자 산술 연산자 : +, -, *, /, %, ++ (증감 연산자), – (감소 연산자) 관계 연산자 : ==, !==, &gt;, &gt;=, &lt;, &lt;= 비트 연산자 &amp; (AND), | (OR) , ^ (XOR), ~ (NOT/ 단항 연산자로서 모든 비트 반전) &lt;&lt; ( 비트를 왼쪽 한 칸 이동 / 2배 ), &gt;&gt; ( 비트를 오른쪽 한 칸 이동 / 2 나누기의 몫 ) 논리 연산자 : ! (NOT), &amp;&amp; (AND), || (OR) 대입 연산자 : +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;= 조건 연산자 : 조건? 수식 1 : 수식 2 참이면 수식 1, 거짓이면 수식 2 연산자 우선 순위 [ 단산시 관비 논조대 ] 단항 : !, ++, –, ~ 산술 : *, /, %, +, - 시프트 : &gt;&gt;, &lt;&lt; 관계 : &lt;, &lt;=, &gt;=, &gt;, ==, != 비트 : &amp;, ^, | 논리 : &amp;&amp;, || 조건 : □ ? 1 : 2 대입 : =, +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;= 데이터 입출력 키보드로 입력 받아 화면으로 출력할 때 사용하는 함수 scanf(), getchar(), gets(), printf(), putchar(), puts() scanf() 함수 : 변수를 저장하는 함수 scanf(서식 문자열, 변수의 주소) 서식 문자열 %d(10진수 정수), %o(8진수 정수), %x(16진수), %c(문자), %s(문자열), %f(소수점 포함 실수) 변수의 주소 &amp;를 붙인다. 서식 문자열 앞에는 숫자를 적으면 자릿수가 확보 printf() 함수 : 주어진 값을 화면에 출력하는 함수, 숫자 없는 기본 자릿수 6개 printf(서식 문자열, 변수) 제어 문자 NULL 문자 출력 : \\0 JAVA 표준 출력 System.out.print() ( f, ln, … ) 기타 표준 입출력 함수 입력 getchar() : 키보드로 한 문자를 입력 받아 변수에 저장 gets() : 문자열로 인식 저장 출력 putchar() : 한 문자를 화면에 출력 puts() : 문자열을 출력한 후 다음 줄로 이동","link":"/2023/07/22/2023/07/2%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A0/"},{"title":"JAVA - 배열 - ② 다차원 배열","text":"목차 배열 정의 다차원 배열 배열 선언 형식 주의할 점 배열 정의 동일한 데이터 타입의 여러 데이터를 하나의 묶음으로 다루는 것이다. 다차원 배열 배열 요소로 또 다른 배열을 가진 배열이다. ex) 2차원 배열 a[0][0] a[0][1] a[0][2] a[0][3] … a[1][0] a[1][1] a[1][2] a[1][3] … a[2][0] a[2][1] a[2][2] a[2][3] … 배열 선언 형식 예시1234567891011121314151617// ①데이터타입[][] 변수명 = new 데이터타입[길이][길이];데이터타입[] 변수명[] = new 데이터타입[길이][길이];데이터타입 변수명[][] = new 데이터타입[길이][길이];// ②데이터타입[][] 변수명;변수명 = new 데이터타입[][] { {변수1, 변수2, ....}, { 변수1, 변수2, .... } };데이터타입[] 변수명[];변수명 = new 데이터타입[][] { {변수1, 변수2, ....}, { 변수1, 변수2, .... } };데이터타입 변수명[][];변수명 = new 데이터타입[][] { {변수1, 변수2, ....}, { 변수1, 변수2, .... } };// ③데이터타입[][] 변수명 = { {변수1, 변수2, ....}, { 변수1, 변수2, .... } };데이터타입[] 변수명[] = { {변수1, 변수2, ....}, { 변수1, 변수2, .... } };데이터타입 변수명[][] = { {변수1, 변수2, ....}, { 변수1, 변수2, .... } }; 코드 1234567891011121314151617181920212223242526272829303132333435// 방식 ①int[][] a = new int[3][3];double[] aa[] = new double[3][3];String aaa[][] = new String[3][3];// 방식 ②int[][] b;b = new int[][] { { 1, 2, 3, 4}, { 2, 3, 4, 5}}; double[] bb[];bb = new double[][] { { 1, 2, 3, 4}, { 2, 3, 4, 5}};String bbb[][];bbb = new String[][] { { &quot;일&quot;, &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;}, { &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;, &quot;오&quot;}};// 방식 ③int[][] c = { { 1, 2, 3, 4}, { 2, 3, 4, 5}};double[][] cc = { { 1, 2, 3, 4}, { 2, 3, 4, 5}};String ccc[][] = { { &quot;일&quot;, &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;}, { &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;, &quot;오&quot;}}; 출력 12345678910111213141516171819202122232425// 방식 ① Arrays 클래스 사용System.out.println(Arrays.toString(b[0]));System.out.println(Arrays.toString(bb[0]));System.out.println(Arrays.toString(bbb[0]));System.out.println();// 방식 ② 반복문 for 문 사용for (int i = 0; i &lt; c.length; i++) { for (int j = 0; j &lt; c[i].length; j++) { System.out.print(c[i][j] + &quot; &quot;); System.out.print(cc[i][j] + &quot; &quot;); System.out.print(ccc[i][j]); System.out.println(); }}System.out.println();// 방식 ③ 반복문 foreach 문 사용for (String[] str : ccc) { for (String s : str) { System.out.print(s + &quot; &quot;); } System.out.println();} 결과 주의할 점 배열 요소에 배열이 있기 때문에, 1차원 배열처럼 출력하면 배열 주소가 출력된다. 코드 1System.out.println(Arrays.toString(b)); 결과","link":"/2023/07/24/2023/07/JAVA-%EB%B0%B0%EC%97%B4-%E2%91%A1/"},{"title":"JAVA - 반복문 - for 문","text":"반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문이다. 종류 : while 문, do ~ while 문, for 문, foreach 문 for 문 초기값, 조건식, 증감식을 앞에 정의하여 한 눈에 보기 쉬운 형식의 반복문이다. 초기값에서 증감식 ( ++ / – 등 ) 에 따라 조건식이 참인 경우 반복문 안의 실행문을 실행한다. 사용 형식 예시 123for(초기값; 조건식; 증감식) { 실행문;} 앞선 반복문(while, do ~ while)과 같이 실행문이 한 줄인 경우, 블록 기호 { } 생략 가능하다. 참고 : depra3’s 반복문 - do~while문 코드 123for (int i = 0; i &lt; 10; i++) { System.out.println(&quot;i = &quot; + i);} 결과 중첩 for 문 for 문을 중첩해서 사용할 수 있다. 사용 형식 예시 1234567for(초기값; 조건식; 증감식) { 실행문; for(초기값; 조건식; 증감식) { 실행문; } 실행문;} 원하는 만큼 중첩해서 사용할 수 있다. 코드 123456for (int i = 1; i &lt; 11; i++) { for (int j = 0; j &lt; i; j++) { System.out.print(&quot;*&quot;); } System.out.println();} 결과 for (int j = 0; j &lt; i; j++) 에서 j &lt; i 를 j &lt; 11 - i 로 변경하면 역으로 나열된다.","link":"/2023/07/18/2023/07/JAVA-%EB%B0%98%EB%B3%B5%EB%AC%B8-for%EB%AC%B8/"},{"title":"JAVA-연산자-③ 증감, 관계(비교)","text":"증감 연산자 변수의 값을 1 증가 또는 감소시키는 연산자 연산자 기호 설명 ++ 1 증가 – 1 감소 코드 1234567891011121314int a = 10;System.out.println(&quot;a = &quot; + a);// a = a + 1; 와 같음a++;System.out.println(&quot;a++ =&gt; &quot; + a);++a;System.out.println(&quot;++a =&gt; &quot; + a);// a = a - 1; 와 같음a--;System.out.println(&quot;a-- =&gt; &quot; + a);--a;System.out.println(&quot;--a =&gt; &quot; + a); 결과 주의 : 증감 연산자 위치에 따른 차이가 있어서 순서가 중요가 중요하다. ++a/—a 인 경우 증감하여 계산 후, 다른 연산자와 계산 a++/a— 인 경우 다른 연산자와 계산 후, 증감하여 계산 코드 1234567891011// 증감 먼저 계산 후 다른 연산자와 계산int b = 9;int c = ++b * 10;System.out.println(&quot;b = &quot; + b);System.out.println(&quot;++b * 10 = &quot; + c);// 다른 연산자와 계산 후 다른 연산자와 계산int d = 9;int e = d++ * 10;System.out.println(&quot;d = &quot; + d);System.out.println(&quot;d++ * 10 = &quot; + e); 결과 관계(비교) 연산자 2개의 값의 관계를 비교하여 true, false를 판별한다. 크기 비교 연산자 기호 설명 &gt; 좌측 값이 우측 값보다 크면 true, 아니면 false &gt;= 좌측 값이 우측 값보다 크거나 같으면 true, 아니면 false &lt; 좌측 값이 우측 값보다 작으면 true, 아니면 false &lt;= 좌측 값이 우측 값보다 작거나 같으면 true, 아니면 false 코드 123456789101112131415System.out.println(&quot;3 &gt; 2 = &quot; + (3&gt;2));System.out.println(&quot;3 &gt; 3 = &quot; + (3&gt;3));System.out.println(&quot;2 &gt; 3 = &quot; + (2&gt;3));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &gt;= 2 = &quot; + (3&gt;=2));System.out.println(&quot;2 &gt;= 2 = &quot; + (2&gt;=2));System.out.println(&quot;1 &gt;= 2 = &quot; + (1&gt;=2));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &lt; 2 = &quot; + (3&lt;2));System.out.println(&quot;3 &lt; 3 = &quot; + (3&lt;3));System.out.println(&quot;2 &lt; 3 = &quot; + (2&lt;3));System.out.println(&quot;-------------&quot;);System.out.println(&quot;3 &lt;= 2 = &quot; + (3&lt;=2));System.out.println(&quot;2 &lt;= 2 = &quot; + (2&lt;=2));System.out.println(&quot;1 &lt;= 2 = &quot; + (1&lt;=2)); 결과 동등 비교 연산자 기호 설명 == 좌측 값과 우측 값이 같으면 true, 아니면 false != 좌측 값과 우측 값이 다르면 true, 아니면 false 코드 12345System.out.println(&quot;1 == 1 = &quot; + (1==1));System.out.println(&quot;1 == 2 = &quot; + (1==2));System.out.println(&quot;-------------&quot;);System.out.println(&quot;1 != 1 = &quot; + (1!=1));System.out.println(&quot;1 != 2 = &quot; + (1!=2)); 결과 문자 비교 문자 비교시 아스키 코드에 기반하여 비교를 한다. 참고 : 아스키 코드(ASCII) 코드 123456789101112char a = 'A';char b = 'B';// A &gt; B 일 때, false 출력System.out.println(&quot;A &gt; B = &quot; + (a&gt;b));// 간단하게 A와 B의 차이 출력 =&gt; -1이 출력되어 1의 차이인 것을 확인 할 수 있다System.out.println(a-b);// 정수형으로 형변환 하여 출력 =&gt; A = 65, B = 66인 것을 알 수 있다.int c = (int)a;int d = (int)b;System.out.println(&quot;A = &quot; + c);System.out.println(&quot;B = &quot; + d); 결과","link":"/2023/07/10/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A2%20%EC%A6%9D%EA%B0%90,%20%EA%B4%80%EA%B3%84(%EB%B9%84%EA%B5%90)/"},{"title":"JAVA - 배열 - ① 1차원 배열","text":"배열 정의 동일한 데이터 타입의 여러 데이터를 하나의 묶음으로 다루는 것이다. 1 차원 배열 선형 구조로 이루어진 묶음이다. a[0] a[1] a[2] … 일 이 삼 … 배열 선언 형식 예시12345678910111213// ①데이터타입[] 변수명 = new 데이터타입[길이];데이터타입 변수명[] = new 데이터타입[길이];// ②데이터타입[] 변수명;변수명 = new 데이터타입[] { 변수1, 변수2, ....};데이터타입 변수명[];변수명 = new 데이터타입[] { 변수1, 변수2, ....};// ③데이터타입[] 변수명 = { 변수1, 변수2, ....};데이터타입 변수명[] = { 변수1, 변수2, ....}; 코드 12345678910111213// 방식 ①int[] a = new int[10];String aa[] = new String[10];// 방식 ②int[] b;b = new int[] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};String bb[];bb = new String[] {&quot;일&quot;, &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;, &quot;오&quot;, &quot;육&quot;, &quot;칠&quot;, &quot;팔&quot;, &quot;구&quot;, &quot;십&quot;};// 방식 ③int[] c = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};String cc[] = {&quot;일&quot;, &quot;이&quot;, &quot;삼&quot;, &quot;사&quot;, &quot;오&quot;, &quot;육&quot;, &quot;칠&quot;, &quot;팔&quot;, &quot;구&quot;, &quot;십&quot;}; 출력 1234567891011121314// 방식 ① Arrays 클래스 사용System.out.println(Arrays.toString(b));System.out.println(Arrays.toString(bb));// 방식 ② 반복문 for 문 사용for (int i = 0; i &lt; c.length; i++) { System.out.println(c[i]);}System.out.println(&quot;--&quot;);// 방식 ③ 반복문 foreach 문 사용for (String arr : cc) { System.out.println(arr);} 방식 ③ 참고 : Depra3’s foreach 문 결과 ★ 주의사항 ★선언 시 주의할 점 코드 123456// error 발생 Xint[] c = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};// error 발생 Oint[] d;d = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; 배열 c에서는 Error가 발생하지 않는다. 그러나 배열 d와 같이 2 줄로 정의하면 컴파일 Error가 발생한다. 출력 시 주의할 점 코드 1234567// 배열 내용 출력System.out.println(Arrays.toString(b));System.out.println(Arrays.toString(bb));// 배열 주소 출력System.out.println(c);System.out.println(cc); Arrays 클래스, 반복문을 이용하지 않고 그대로 변수명을 이용하여 출력하면 배열의 주소가 출력이 된다.","link":"/2023/07/20/2023/07/JAVA-%EB%B0%B0%EC%97%B4-%E2%91%A0/"},{"title":"JAVA-조건문-IF문","text":"조건문 프로그램 흐름에 원하는 기준을 조건으로 분기를 추가하여 흐름을 제어할 때 이용한다. 종류 : if 문, if ~ else 문, if ~ else if ~ else 문, 중첩 if문, switch - case 문 블럭 { } 중괄호로 표현하며, 여러 코드들을 하나로 묶어 블럭처럼 만들어 준다. IF 문 조건식이 참(true)인 경우, 실행문을 실행한다. 조건식이 거짓(false)인 경우, 실행문을 실행하지 않는다. 사용 형식 ① 예시 1234567if( 조건식 ) { // 조건식이 참인 경우 실행되는 코드 실행문; 실행문; 실행문; ...} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 코드 1234567int a = 1;if (a &gt; 0) { System.out.println(&quot;a는 0이 아니다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 1이다.&quot;);} 결과 사용 형식 ② 예시 1234567// 두가지 형식으로 사용 가능하다.// 1if( 조건식 ) 실행문;// 2if( 조건식 ) 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 코드 123456int a = 1;if(a &gt; 0) System.out.println(&quot;a=1&quot;);if(a &gt; 0) System.out.println(&quot;a=1&quot;); 결과 IF ~ else 문 조건식에 대해 참(true)이 아닌 경우에 실행할 코드들을 추가할 때 이용 조건식이 참(true)인 경우, else 앞의 { } 에서 실행문을 실행한다. 조건식이 거짓(false)인 경우, else 뒤의 { } 에서 실행문을 실행한다. 사용 형식 ① 예시 123456789if ( 조건식 ) { // 조건식이 참인 경우 실행되는 코드 실행문; 실행문;} else { // 조건식이 거짓인 경우 실행되는 코드 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 코드 123456789int a = 0;if (a &gt; 0) { System.out.println(&quot;a는 0이 아니다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 1이다.&quot;);} else { System.out.println(&quot;a는 0보다 크지 않다.&quot;); System.out.println(&quot;a는 0일 수 있다.&quot;);} 결과 사용 형식 ② 예시 12if ( 조건식 ) 실행문;else 실행문; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 코드 1234int a = 0; if (a &gt; 0) System.out.println(&quot;a는 0보다 크다.&quot;); else System.out.println(&quot;a는 0보다 크지 않다.&quot;); 결과 IF ~ else if ~ else 문 앞서 이용했던 IF ~ else 문에서 조건식을 추가하여 조금 더 다양하게 분기를 나누고 싶을 때는 IF ~ else if ~ else 문을 이용한다. 조건식 ① 에서 참인 경우 실행문 ① 실행, 거짓인 경우 조건식 ② 에서 참, 거짓을 구분한다. 조건식 ② 에서 참인 경우 실행문 ② 실행, 거짓인 경우 실행문 ③ 을 실행한다. 사용 형식 ① 예시 12345678910111213if ( 조건식 ① ) { // 조건식 ① 이 참인 경우 실행되는 코드 실행문; 실행문;} else if( 조건식 ② ) { // 조건식 ① 이 거짓, 조건식 ② 가 참인 경우 실행되는 코드 실행문; 실행문;} else { // 조건식 ① 과 ② 가 참인 경우 실행되는 코드 실행문; 실행문;} 실행문이 두 줄 이상인 경우, 블록 기호 { } 를 생략할 수 없다. 코드 1234567891011int a = 0;if (a &gt; 0) { System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;);} else if ( a == 0 ){ System.out.println(&quot;a는 0이다.&quot;); System.out.println(&quot;a는 0이다.&quot;);} else { System.out.println(&quot;a는 0보다 작다.&quot;); System.out.println(&quot;a는 0보다 작다.&quot;);} 결과 사용 형식 ② 예시 123if ( 조건식 ① ) 실행문①;else if( 조건식 ② ) 실행문②;else 실행문③; 실행문이 한 줄인 경우, 블록 기호 { } 를 생략할 수 있다. 코드 1234int a = 0;if (a &gt; 0) System.out.println(&quot;a는 0보다 크다.&quot;); else if(a == 0) System.out.println(&quot;a는 0이다.&quot;);else System.out.println(&quot;0는 0보다 작다.&quot;); 결과 중첩 IF 문 횟수 제한 없이 IF문을 중첩하여 사용할 수 있다. 사용하는 IF문들 안에서 분기를 나누고 싶을 때 사용한다. 사용 형식 예시 1234567891011121314151617181920if ( 조건식 ① ) { // 조건식 ① 이 참인 경우 실행되는 코드 실행문; if ( 조건식 ② ) { // 조건식 ② 이 참인 경우 실행되는 코드 실행문; } else if ( 조건식 ③ ) { // 조건식 ② 이 거짓, 조건식 ③ 이 참인 경우 실행되는 코드 실행문; } else { // 조건식 ② 와 ③ 이 거짓인 경우 실행되는 코드 실행문; }} else if( 조건식 ④ ) { // 조건식 ① 이 거짓, 조건식 ④ 가 참인 경우 실행되는 코드 실행문;} else { // 조건식 ① 과 ④ 가 거짓인 경우 실행되는 코드 실행문;} 코드 123456789101112131415161718int a = 1;if (a &gt; 0) { System.out.println(&quot;a는 0보다 크다.&quot;); System.out.println(&quot;a는 0보다 크다.&quot;); if (a == 1) { System.out.println(&quot;a == 1&quot;); } else if (a == 2) { System.out.println(&quot;a == 2&quot;); } else { System.out.println(&quot;a == ??&quot;); }} else if ( a == 0 ){ System.out.println(&quot;a는 0이다.&quot;); System.out.println(&quot;a는 0이다.&quot;);} else { System.out.println(&quot;a는 0보다 작다.&quot;); System.out.println(&quot;a는 0보다 작다.&quot;);} 결과","link":"/2023/07/12/2023/07/JAVA-%EC%A1%B0%EA%B1%B4%EB%AC%B8-IF%EB%AC%B8/"},{"title":"JAVA-연산자-① 정의, 종류, 우선 순위","text":"연산자 정의 연산 프로그램에서 데이터를 처리하여 결과를 산출하는 것 연산자 산술, 부호, 문자열, 대입, 증감, 비교, 논리, 조건 등의 연산을 하는 데에 사용되는 표시나 기호 피연산자 연산 시에 연산이 되어지는 대상 예시 A + B 의 식에서 A, B 변수가 피연산자 연산식 ( = 표현식 ) 연산자와 피연산자를 통해 각 변수 또는 상수가 연산을 하는 식 연산자의 종류 피연산자 개수로 연산자 분류 단항 연산자 : ++, —, !, ^ 등 이항 연산자 : +, -, *, / 삼항 연산자 : (조건식) ? A : B 보통 대부분의 연산자는 이항 연산자다. 연산자 우선 순위 연산식에 사용된 연산자가 둘 이상일 경우, 연산자의 우선 순위에 의해 연산 순서가 결정된다. 단항 연산자(ex. ++,— 등)가 이항 연산자(ex. +,- 등)보다 우선 순위가 높다. 단항 &gt; 이항 &gt; 삼항 산술 &gt; 비교 &gt; 논리 &gt; 대입 우선 순위가 확실하지 않다면, 괄호 ()를 이용하여 묶어주어야 한다. 괄호 안의 계산식이 우선 순위가 제일 높다. 연산자의 결합 규칙은 왼쪽에서 오른쪽 순서이지만, **대입 연산자 (제일 늦음)**는 오른쪽에서 왼쪽으로 진행된다. 예시 1234567891011// 연산자 결합 규칙int a = 10 * 10 * 10;// 순서 : 왼쪽에서 오른쪽a = (10 * 10) * 10 = 100 * 10 = 1000// 대입 연산자 결합 규칙a = b = c = 10;// 순서 : 오른쪽에서 왼쪽c = 10b = ca = b","link":"/2023/07/04/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A0%20%EC%A0%95%EC%9D%98,%20%EC%A2%85%EB%A5%98,%20%EC%9A%B0%EC%84%A0%20%EC%88%9C%EC%9C%84/"},{"title":"JAVA-연산자-② 산술, 부호, 문자열, 대입","text":"산술 연산자 가장 기본이 되는 연산자로 **4칙 연산( +, -, *, /)**과 나머지 값을 구하는 **나머지 연산자(%)**가 있다. 연산자 기호 설명 + 두 수에 대한 덧셈 - 두 수에 대한 뺄셈 * 두 수에 대한 곱셈 / 두 수에 대한 나눗셈 % 두 수를 나눈 후 나머지를 반환 코드 1234567891011int a = 10;System.out.println(&quot;a + 5 = &quot; + (a + 5));// 10 + 5 =&gt; 15System.out.println(&quot;a - 5 = &quot; + (a - 5));// 10 - 5 =&gt; 5System.out.println(&quot;a * 5 = &quot; + (a * 5));// 10 * 5 =&gt; 50System.out.println(&quot;a / 5 = &quot; + (a / 5));// 10 / 5 =&gt; 2System.out.println(&quot;a % 5 = &quot; + (a % 5));// 10 % 5 =&gt; 나머지는 0 결과 부호 연산자 단항 연산자로 양수/음수를 표현하고 값의 부호를 결정 연산자 기호 설명 + 변수에 +1을 곱함 - 변수에 -1을 곱함 코드 12345678910111213int a = 10;System.out.println(&quot;+a = &quot; + (+a));// a 변수값 그대로 출력System.out.println(&quot;-a = &quot; + (-a));// a 변수값을 음수로 변환하여 출력System.out.println(&quot;----------&quot;);int b = -a; // 의도 : a 변수값을 음수로 변환하여 대입System.out.println(&quot;b = &quot; + b);int c = +b; // 의도 : b 변수값을 양수로 변환하여 대입System.out.println(&quot;c = &quot; + c);int d = -b; // 의도 : b 변수값을 음수로 변환하여 대입System.out.println(&quot;d = &quot; + d); 결과 +a와 -a는 의도대로 출력이 된다. 그러나 변환하여 대입할 때 변수 b와 달리 변수 c와 변수 d는 생각과 다르게 표시되는 것을 볼 수 있다. 풀어서 쓰면 c = +(-10) ⇒ c = -10 // d = -(-10) ⇒ d = 10 와 같이 볼 수 있다. 결론 부호 연산자는 단순하게 +, -로 변환하는 것이 아닌 +1, -1를 곱하여 부호를 변환하는 것이라고 볼 수 있다. 문자열 연산자 이항 연산자이며 두 개의 피연산자 중 하나가 문자열인 경우 문자열로 결합한다. 코드 123System.out.println(1 + 1); // 숫자 1 + 숫자 1 = 2System.out.println(&quot;1&quot; + 1); // 문자열 &quot;1&quot; + 숫자 1 = &quot;1&quot;1System.out.println(&quot;1&quot; + &quot;2&quot;); // 문자열 &quot;1&quot; + 문자열 &quot;2&quot; = &quot;1&quot;&quot;2&quot; 결과 1+1의 연산은 문자열이 없어 산술 계산 한 쪽이 문자열이 있는 경우 다른 쪽의 피연산자가 정수여도 문자열로 결합 대입 연산자 오른쪽에 있는 값을 왼쪽 변수에 대입한다. 연산자 기호 설명 = 오른쪽 값을 왼쪽 변수에 대입 += 왼쪽 변수의 값을 오른쪽 변수로 덧셈 후 왼쪽 변수에 대입 -= 왼쪽 변수의 값을 오른쪽 변수로 뺄셈 후 왼쪽 변수에 대입 *= 왼쪽 변수의 값을 오른쪽 변수로 곱셈 후 왼쪽 변수에 대입 /= 왼쪽 변수의 값을 오른쪽 변수로 나눈 후 왼쪽 변수에 대입 %= 왼쪽 변수의 값을 오른쪽 변수로 나눈 후 나머지 값을 왼쪽 변수에 대입 코드 123456789101112131415161718int a = 10;System.out.println(&quot;a = 10 =&gt; a = &quot; + a);a += 5;System.out.println(&quot;10 += 5 =&gt; a = &quot; + a);// a = 10 + 5a -= 5;System.out.println(&quot;15 -= 5 =&gt; a = &quot; + a);// a = 15 - 5a *= 5;System.out.println(&quot;10 *= 5 =&gt; a = &quot; + a);// a = 10 * 5a /= 5;System.out.println(&quot;50 /= 5 =&gt; a = &quot; + a);// a = 50 / 5a %= 5;System.out.println(&quot;10 %= 5 =&gt; a = &quot; + a);// a = 10 % 5 - 나머지 0 결과","link":"/2023/07/05/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A1%20%EC%82%B0%EC%88%A0,%20%EB%B6%80%ED%98%B8,%20%EB%AC%B8%EC%9E%90%EC%97%B4,%20%EB%8C%80%EC%9E%85/"},{"title":"JAVA-클래스, 인스턴스, 객체","text":"목차 클래스 인스턴스 객체 클래스 객체를 만들어 내기 위한 일종의 설계도 혹는 틀이다. 와플(객체) 을 만들기 위한 와플팬(클래스) 이다. 객체를 만들어 내기 위해 필요한 속성(변수) 과 동작(메서드) 으로 이루어져 있다. 인스턴스 클래스(설계도 혹은 틀)를 바탕으로 소프트웨어 세계에 구현된 구체적인 실체이다. 와플팬(클래스) 을 통해 만들어낸 와플(객체) 하나하나를 해당 클래스의 인스턴스라고 한다. 와플(객체) 마다 딸기 와플, 바나나 와플 등으로 다르지만, 하나의 와플팬(클래스) 을 통해 만들어낸 경우 해당 클래스의 인스턴스인 것이다. 객체 클래스(설계도)로 구현한 모든 대상이다. 인스턴스와 혼용해서 표현하기도 한다. 참고 : Depra3’s JAVA - 객체","link":"/2023/07/26/2023/07/JAVA-%ED%81%B4%EB%9E%98%EC%8A%A4,%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4,%EA%B0%9D%EC%B2%B4/"},{"title":"정보처리 산업기사(2023) 1과목-1장-①","text":"정보 시스템 기반 기술1장 응용 SW 기초 기술 활용 Key Words 운영체제, UNIX, 커널, 쉘, IP6, OSI 참조 모델, 라우터, 프로토콜, TCP, UDP 운영체제 운영체제의 목적 ( OS : Operating System) 처리 능력 (Throughtput) 반환 시간 (Turn Around Time) 사용 가능도 (Availability) 신뢰도 (Reliability) 운영체제의 기능 (os) 프로세서, 기억 장치, 입출력 장치, 파일 및 정보 관리 스케줄링, 인터페이스, 공유 기능, 자원 보호 기능, 입출력 장치 보조 기능, 가상 계산기 기능 제공 시스템 오류 검사, 복구 하드웨어와 네트워크 관리 및 제어 커널의 기능 : 운영체제 주요 자원 관리 [ 프기주파 ] 프로세스 관리 기억 장치 관리 주변 장치 관리 파일 관리 쉘의 기능 : 사용자 인터페이스, 명령어 해석 운영체제 종류 Windows, MacOS, UNIX, LINUX (다중 작업 처리) MS-DOS (단일 작업 처리) Windows windows는 1990년대 마이크로소프트 사가 개발한 운영체제이다. 특징 그래픽 사용자 인터페이스 (GUI) 키보드 명령어를 직접 입력하지 않고 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식 선점형 멀티태스킹 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU이용 시간을 제어하여 응용 프로그램 실행 중 문제가 발생하면 해당 프로그램을 강제 종료 시키고 모든 시스템 자원을 반환하는 방식 PnP(자동 감지 기능) ( Plug and Play ) 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때 해당 하드웨어를 사용하는 데 필요한 환경을 운영체제가 자동으로 구성해 주는 기능 OLE (Object Linking and Embedding) 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체를 현재 작성 중인 문서에 자유롭게 연결하거나 삽입하여 편집할 수 있게 하는 기능 255자의 긴 파일 명 Windows에서는 파일 이름을 지정할 때 VFAT를 이용하여 최대 255자까지 지정할 수 있다.파일 이름으로는 / / : * ? &lt; &gt; | 를 제외한 모든 문자 및 공백을 사용할 수 있으며 한글의 경우 127자까지 지정할 수 있다. Single-User 시스템컴퓨터 한 대를 한 사람만이 독점해서 사용한다. Windows 기본 명령어 UNIX 개요 및 특징 [ 대다이계통 ] 1960년대 AT&amp;T 벨(Bell) 연구소, MIT, General Electric이 공동 개발한 운영체제 대화식 운영체제 ( 시분할 시스템을 위함 - 개방형 시스템 ) 다중 작업, 다중 사용자 이식성 ( C언어로 작성 ) 계층적 트리 구조 파일 많은 네트워킹 기능으로 통신망 관리용 운영체제로 적합 UNIX 시스템 구성 커널 (Kernel) UNIX의 핵심적인 부분 부팅시 주기억장치에 적재된 후 상주하면서 실행 하드웨어를 보호하고 프로그램과 하드웨어 간의 인터페이스 역할 담당 프로세스(CPU 스케줄링) 관리, 기억 장치 관리, 파일 관리, 입 출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 기능을 수행 쉘 (Shell) 명령어 해석기 시스템과 사용자간의 인터페이스 담당 DOS의 COMMAND와 같은 기능 수행 주기억장치에 상주하지 않고 명령어가 포함된 파일 형태로 존재, 보조 기억 장치에서 교체 처리 가능 파이프라인 기능을 지원하고 입 출력 재지정을 통해 출력과 입력의 방향을 변경할 수 있다. 공용 Shell이나 사용자 자신이 만든 Shell을 사용할 수 있다. Utility Program 일반 사용자가 작성한 응용 프로그램을 처리하는데 사용한다. DOS에서의 외부 명령어에 해당한다. 유틸리티 프로그램에는 에디터, 컴파일러, 인터프리터, 디버거 등이 있다. UNIX &amp; LINUX 기본 명령어 인터넷 인터넷 IP주소 (Internet Protocol Address) 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소 숫자로 8비트씩 4부분, 총 32비트 표현 A클래스에서 E클래스까지 총 5단계로 구성 A Class: 국가나 대형 통신망에 사용(0~127로 시작) B Class: 중대형 통신망에 사용(128~191로 시작) C Class: 소규모 통신망에 사용(192~223으로 시작) D Class: 멀티캐스트용으로 사용(224~239으로 시작) E Class: 실험적 주소이며 공용되지 않음 서브네팅 (Subnetting) 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용 4byte의 IP주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용한다. 서브넷 마스크는 각 클래스마다 다르게 사용된다. IPv6 (Internet Protocol Version 6) 현재 사용하고 있는 IP주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발 128bit의 긴 주소를 사용하여 주소 부족 문제를 해결, IPv4에 비해 자료 전송 속도가 빠름 인증성, 기밀성, 무결성의 지원으로 보안 문제를 해결 IPv4와 호환성이 뛰어남 주소의 확장성, 융통성, 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능을 지원 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다. IPv6의 구성 [ 유멀애 ] 16bit씩 8부분, 총 128bit로 구성 각 부분을 16진수로 표현, 콜론(:)으로 구분 3가지 주소 체계 유니캐스트(1:1), 멀티캐스트(1:N), 애니캐스트(가까이 있는 1:1) 도메인 네임 도메인 네임은 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현 호스트 컴퓨터 이름, 소속 기관 이름, 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미한다.","link":"/2023/06/23/2023/06/1%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A0/"},{"title":"Git &amp; Github 연결 설정","text":"☆ 다운로드 링크 ☆ Git Downloads 사용자가 사용하는 OS(운영체제) 선택하여 다운로드 합니다. ( 글쓴이는 Windows 10이므로 Windows 선택 ) 사용자가 사용하는 OS bit를 선택하여 다운로드 합니다. ( 글쓴이는 64bit이므로 64bit 선택 ) 설치 후 실행. (Default) 바탕화면에서 마우스 오른쪽 클릭 후 Git Bash here 클릭 git —version입력하여 설치 확인 ① code 클릭 → ② 클릭 git clone “링크” 바탕화면에 생긴 파일 위에 오른쪽 클릭 Visual Studio Code 로 실행(단, 환경변수가 설정되어야함) 참고 : Visual Studio Code 설치 및 환경 설정 해당 사이트(https://www.toptal.com/developers/gitignore)에서 사용하는 언어 입력] ex) Python, R 나온 텍스트 내용을 복사 VS Code에서 .gitignore에 붙여넣기(맨 아랫줄에 붙여넣기) 터미널 생성 후 powershell이 아닌 git bash로 체크 후 git add .gitignore 입력 나오는 오류는 로그인이 되지 않아서 발생함. 따라서 로그인해야함. 첫 줄은 로그인 ID, 두번째 줄은 닉네임으로 연결 git config —global user.email “연결할 해당 github 가입 Email” git config —global user.name “연결할 해당 github 닉네임” 마지막으로 git push ( 로컬(local branch)에서 원격 저장소(remot repository)로 보낼 때 사용하는 명령어) 로 마무리 나오는 사이트에서 Authorize 클릭 연결 완료 된 것 확인 아래 코드를 입력하여 업로드 git add . git commit -m “updated” ※ update부분은 git commit message의 내용 git push 변경이 되었는지 확인 File과 Repository를 같은 이름으로 하는 연결 방법 File명과 Repository를 같은 이름으로 한 후 File을 우클릭하여 Git Bash Here 실행 후 아래 부분의 코드를 한 줄 씩 입력","link":"/2023/06/21/2023/06/Git&Github/"},{"title":"정보처리 산업기사(2023) 1과목-2장-①","text":"정보 시스템 기반 기술2장 애플리케이션 설계 폭포수 모형, 나선형 모형, 애자일, 스크럼, XP, UML, UML 다이어그램, 클래스, 캡슐화, 디자인 패턴 소프트웨어 생명주기 정의 소프트웨어 생명 주기는 소프트웨어 개발 방법론의 바탕이 되는 것으로 소프트웨어를 개발하기 위해 정의하고 운용 유지보수 등의 과정을 각 단계로 나눈 것이다. 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 및 활동의 결과에 대한 산출물로 표현한다. 소프트웨어 생명 주기를 표현하는 형태를 소프트웨어 생명 주기 모형이라고 하며 소프트웨어 프로세스 모형 또는 소프트웨어 공학 패러다임이라고 한다. 폭포수 모형, 프로토타입 모형, 나선형 모형, 애자일 모형 소프트웨어 공학 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이며 여러가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다 소프트웨어 위기의 현상 여려 가지 원인에 의해 소프트웨어 개발 속도가 하드웨어 개발 속도를 따라가지 못해 소프트웨어에 대한 사용자들의 요구 사항을 처리할 수 없는 문제가 발생함을 의미합니다. 개발 인력 부족과 그로 인한 인건비 상승 개발 기간 지연 및 개발 비용 증가 유지 보수의 어려움과 이에 따른 비용 증가 소프트웨어의 생산성과 품질 저하 소프트웨어 개발 프로세스 폭포수 모형 (Waterfall Model) 이전 단계로 돌아갈 수 없다는 전제 하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론 고전적 생명 주기 모형 선형 순차적 모형 : 한 단계가 끝나고 다음 단계로 넘어감 경험과 성공 사례 많음 메뉴얼 작성 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다 두 개 이상의 과정 병행 불가 프로토타입 / 프로토타이핑 모형 (Prototyping Model) 사용자와 시스템 사이의 인터페이스 중점 완료되면 오류가 발견되는 폭포수의 단점을 보완 사용자의 요구 사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물 예측 나선형 모형 = 점진적 모형 (Spiral Model) 보헴(Boehm)이 제안한 것으로 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형 ( 폭포수 + 프로토타입 + 분석 기능 추가 ) 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 것으로 점진적 모형 위험을 관리하고 최소화하는 목적 점진적으로 개발 과정이 반복되므로 누락되거나 추가된 요구 사항을 첨가할 수 있고, 정밀하며, 유지 보수 과정이 필요 없음 애자일 모형 애자일은 민첩한, 기만한이라는 의미로 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭 스프린트, 이터레이션 짧은 개발 주기 에자일 모형을 기반으로 하는 소프트웨어 개발 모형에는 스크럼,XP,칸반,Lean,크리스탈,ASD,기능 중심 개발, DSDM, DAD 등이 있다. 애자일 개발 4가지 핵심 가치 프로세서와 도구 보다 개인과 상호작용에 초점 문서보다 실행되는 SW에 가치를 둠 고객과의 협업 가치 계획을 따르기 보다 변화에 반응 소프트웨어 방법론 구조적, 정보공학, 객체 지향, 컴포넌트(CBD) 기반, 애자일, 제품 설계 방법론 구조적 방법론 1960 년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론 정형화된 분석 절차에 따라 사용자 요구 사항을 파악하여 문서화 하는 처리 중심 방법론 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적 복잡한 문제를 다루기 위해 분할과 정복 원리 적용 정보 공학 방법론 정보 시스템 개발을 위해 계획, 분석, 설계 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합 절차 정보 전략 계획 수립 단계 → 업무 영역 분석 단계 → 업무 시스템 설계 단계 → 업무 시스템 구축 단계 객체 지향 방법론 하나의 객체로 만들어 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택 객체 지향 방법론 구성 요소 [ 객클메 ] 객체, 클래스, 메세지 등 객체 지향 방법론 기본 원칙 [ 정관다 캡상추 ] 정보은닉, 관계성, 다형성, 캡슐화, 상속성, 추상화 절차 요구 분석 단계 → 설계 단계 → 구현 단계 → 테스트 및 검증 단계 → 인도 단계 컴포넌트 기반(CBD) 방법론 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론 컴포넌트의 재사용이 가능하며 시간과 노력을 절감 새로운 기능 추가가 간단하여 확장성 보장 유지 보수 비용 최소화하고 생산성 및 품질을 향상 시킬 수 있음 절차 개발 준비 단계 → 분석 단계 → 설계 단계 → 구현 단계 → 테스트 단계 → 전개 단계 → 인도 단계 애자일 방법론 애자일은 민첩한, 기만한이라는 의미로 애자일 방법론은 고객의 요구 사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발 과정을 진행하는 방법론 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구 사항에 적합 대표적인 종류에는 익스트럼 프로그래밍, 스크럼,칸반,크리스탈 등 절차 사용자 스토리 → 반복 주기 [ 계획 → 개발 → 승인 테스트 ] 요구 사항 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약 조건 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공 요구 사항의 유형 기능 요구 사항 시스템이 무엇을 하는지 / 입력이나 출력으로 무엇이 포함되어야 하는지 / 반드시 수행해야 하는 기능 / 제공 받기를 원하는 기능 비기능 요구 사항 장비 구성 / 성능 / 인터페이스 / 데이터 / 테스트 / 보안 / 품질 / 제약 사항 / 프로젝트 관리 / 프로젝트 지원 사용자 요구 사항 사용자 관점에서 본 시스템 제공, 사용자를 위한 친숙한 표현 시스템 요구 사항 = 소프트웨어(SW) 요구 사항 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구 사항, 전문적이고 기술적인 용어 표현 요구 사항 개발 프로세스 요구 사항을 체계적 도출, 분석한 후 명세서 정리, 확인 및 검증 도출 (Elicitation) → 분석 (Analysis) → 명세 (Specification) → 확인 (Validation) 요구 사항 도출 인터뷰, 설문, 브레인 스토밍, 워크샵, 프로토파이핑, 유스케이스 (기능적 요구 사항) 요구 사항 분석 자료 흐름도 (DFD), 자료 사전(DD) 요구 사항 명세 사용자가 이해하기 쉽고 개발자가 효과적으로 설계할 수 있도록 작성 (문서화) 소단위 명세 (Mini-Spec) 요구 사항 확인 = 요구 사항 검증 요구 사항 정의 문서들에 대해 형상 관리 수행 구조적 분석 도구 종류 자료 흐름도 (DFD), 자료 사전 (DD), 소단위 명세서(Mini-Spec), 개체 관계도 (ERD), 상태 전이도(STD), 제어 명세서 모델링, 하향식 방법 등을 사용 자료 흐름도 (DFD) : 자료 흐름도 - IT위키 (itwiki.kr) 요구 사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법으로 자료 흐름 그래프, 버블 차트 자료 사전 (DD) 자료, 자료들의 집합, 자료의 흐름, 자료 저장소와 그것들의 관계-범위-단위를 구체적으로 명시하는 것 = : 사용자 정의 is |, [] : 자료의 선택 or + : 자료의 연결 and { } : 자료의 반복 ( ) : 자료의 생략 ** : 자료의 설명 주석 요구 사항 분석을 위한 CASE 요구 사항 분석을 위한 자동화 도구 요구 사항을 자동으로 분석, 요구 사항 분석 명세서 기술 SADT SoftTech 시에서 개발한 것으로 시스템 정의, 소프트웨어 요구 사항 분석, 시스템/소프트웨어 설계를 위해 널리 이용되어 온 구조적 분석 및 설계 도구이다. 블록 다이어그램을 채택 SREM TRW 사가 우주 국방 시스템 그룹에 의해 실시간 처리 소프트웨어 시스템에서 요구 사항을 명확히 기술하도록 할 목적으로 개발한 것으로 **RSL과 REVS를 사용하는 자동화 도구**이다. RSL: 요소, 속성, 관계, 구조들을 기술하는 요구 사항 기술 언어 REVS: RSL로 기술된 요구 사항들을 자동으로 분석하여 요구 사항 분석 명세서를 출력하는 요구 사항 분석기 PSL/PSA 미시간 대학에서 개발한 것으로 PSL과 PSA를 사용하는 자동화 도구이다. PSL (Problem Statement language) : 문제 기술 언어 PSA (Problem Statement Analyzer) : PSL로 기술한 요구 사항을 자동으로 분석하여 다양한 보고서를 출력하는 문제 분석기 TAGS 시스템 공학 방법 응용에 대한 자동 접근 방법으로 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구이다.","link":"/2023/06/30/2023/06/1%EA%B3%BC%EB%AA%A9-2%EC%9E%A5-%E2%91%A0/"},{"title":"JAVA-데이터타입","text":"데이터 타입 정수형 타입 선언 및 출력 byte, short, int, long 타입들을 이용하며, 실수 입력 시에 오류가 발생한다. 코드 123456789byte a = 1;short b = 2;int c = 3;long d = 4;System.out.println(a);System.out.println(b);System.out.println(c);System.out.println(d); 결과 문자형 타입 선언 및 출력 char 타입이며 입출력 시에 ASCII를 참조한다. 코드 12345char a = 'a';char b = 65;System.out.println(a);System.out.println(b); char타입에서는 작은 따옴표(’ ’)를 사용 큰 따옴표(” ”)는 String객체를 이용하여 문자열 변수 선언시 사용 결과 char 타입에 숫자도 입력 받을 수 있으나 출력은 ASCII을 참조하여 출력한다. 참고 자료 : ASCII -위키백과 논리형 타입 선언 및 출력 boolean 타입이며 참(True 또는 1), 거짓(False 또는 0) 2가지 값을 사용한다. 코드 12345boolean a = true;boolean b = false;System.out.println(a);System.out.println(b); 결과 실수형 데이터 타입 부동소수점 표현 방식을 사용 부호 : 1bit에서 +를 0으로, -를 1로 표현한다. 지수 : 지수부분을 표현 예시 : $2^5$ 에서 5가 지수 부분 가수 : 소수점 우측의 숫자 부분을 표현한다. 참고 자료 : 부동소수점 - 위키백과 코드 1234567float a = 1.5f;double b = 2.0;double c = 3.0d;System.out.println(a);System.out.println(b);System.out.println(c); JAVA에서는 실수 선언 시에 double자료형을 기본으로 한다. ( →3.0d에서 d는 생략 가능) 따라서, float 선언 부분에서 f가 붙는 이유이기도 하다. 결과","link":"/2023/06/28/2023/06/JAVA-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85/"},{"title":"JAVA-조건문-Switch~Case문","text":"조건문 프로그램 흐름에 원하는 기준을 조건으로 분기를 추가하여 흐름을 제어할 때 이용한다. 종류 : if 문, if ~ else 문, if ~ else if ~ else 문, 중첩 if문, switch - case 문 Switch ~ Case 문 IF 문과 같은 조건문이지만 다양한 연산자들을 이용하여 조건식을 만들 수 있는 IF 문과 달리 특정 값일 때에 실행문을 실행한다. 사용 형식 예시12345678910switch(변수) { case 값1: 실행문; break; case 값2: 실행문; break; default: 실행문;} Switch ~ Case 문은 Switch 문 에 들어가는 변수를 Case 문 에서 조건을 만들어 특정 값을 지정하면 break 문 전까지 실행문을 실행한다. 만약 모든 Case 문의 조건에 충족되지 않는다면 default의 실행문을 실행하게 된다. 코드 12345678910111213int a = 1;switch (a) { case 1: System.out.println(&quot;1&quot;); System.out.println(&quot;1&quot;); break; case 2: { System.out.println(&quot;2&quot;); break; } default: System.out.println(&quot;default&quot;);} 결과 IF 문과 달리 Case 문에서 블록기호 { } 를 사용하지 않아도 두 줄이상 사용이 가능하다. 참고 : depra3’s JAVA-조건문-IF문 ※ 주의 사항 ※ Case 문 처리 이후 break 문으로 마무리 지어야 한다. 그렇지 않으면 break 문이 나올 때 까지 모든 Case문을 처리한다. 만약 모든 Case 문에 break 문이 없다면, default 문의 실행문 까지 실행한다. 코드 1234567891011int a = 1;switch (a) { case 1: System.out.println(&quot;1&quot;); System.out.println(&quot;1&quot;); case 2: { System.out.println(&quot;2&quot;); } default: System.out.println(&quot;default&quot;);} 결과","link":"/2023/07/14/2023/07/JAVA-%EC%A1%B0%EA%B1%B4%EB%AC%B8-Switch~Case%EB%AC%B8/"},{"title":"정보처리 산업기사(2023) 1과목-1장-②","text":"OSI 참조 모델 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol) OSI 7계층은 1~3계층을 하위 계층, 4~7계층을 상위 계층으로 구분 하위 : 물리 → 데이터 링크 → 네트워크 상위 : 전송 → 세션 → 표현 → 응용 OSI참조모델 데이터 단위 물리 : 비트 데이터 : 프레임 네트워크 : 패킷 전송 : 세그먼트 세션, 표현, 응용 : 메세지 OSI 참조 모델 계층 물리 계층 전송에 필요한 두 장치 간의 기계적, 전기적, 기능적, 절차적 특정에 대한 규칙 정의 데이터 링크 계층 두 개의 인접한 개방 시스템들 간의 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 “시스템 간” 연결 설정과 유지 및 종료 담당, 흐름 제어, 프레임 동기화, 오류 제어, 순서 제어 네트워크 계층 데이터의 교환 및 중계, “네트워크” 연결 설정 / 유지 / 해제 기능, 경로 설정(Routing) 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송 수행 전송(Transport) 계층 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(end-to-end)간의 투명한 데이터 전송 가능 E-T-E간의 전송 연결 설정, 데이터 전송, 연결 해제 기능 세션 계층 송수신 측간의 관련성 유지 대화 구성 및 동기 제어, 데이터 교환 관리, 동기점 표현(presentation) 계층 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신을 적당한 형태로 변환, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식 변환, 문맥 관리 응용 계층 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스 제공 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 서비스 네트워크 관련 장비 네트워크 인터페이스 카드 (NIC) 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치로 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경 물리 허브 (Hub) 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며 신호 증폭 기능을 하는 리피터의 역할도 포함 더미 허브, 스위칭 허브 리피터 (Repeater) 전송되는 신호가 전송 선로의 특성 및 외부 충격 등의 요인으로 인해 원래의 형태와 다르게 왜곡되거나 약해질 경우 원래의 신호 형태로 재생하여 다시 전송하는 역할을 수행 데이터 브릿지 (Bridge) LAN과 LAN 또는 LAN안에서 컴퓨터 그룹(세그먼트)을 연결하는 기능을 수행 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다. 스위치 (Switch) 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치 하드웨어를 기반으로 처리하므로 전송 속도가 빠르다. 네트워크 라우터 (Router) 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택할 수 있는 기능이 추가 된 것으로 서로 다른 LAN이나 LAN과 WAN의 연결도 수행 전송 게이트웨이 (Gateway) 전 계층(1~7계층)의 프로토콜 구조가 다른 네트워크의 연결을 수행한다. LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할을 한다. 프로토콜 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약 구문(Syntax): 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정 의미(Semantics): 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정 시간(Timing): 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정 프로토콜의 기능 단편화와 재결합 단편화(Fragmentation) 송신 측에서 전송할 데이터를 전송에 알맞은 일정 크기의 작은 블록으로 자르는 작업 재결합(Reassembly) 수신 측에서 단편화된 블록을 원래의 데이터로 모으는 작업 캡슐화(Encapsulation) 단편화된 데이터에 송 수신지 주소, 오류 검출 코드, 프로토콜 기능을 구현하기 위한 프로토콜 제어 정보 등의 정보를 부가하는 것으로 요약화라고 한다. 흐름 제어(Flow Control) 수신 측의 처리 능력에 따라 송신 측에서 송신하는 데이터의 전송량이나 전송 속도를 조절하는 기능 정지-대기(Stop-and-wait), 슬라이딩 윈도우(Sliding Window)방식을 이용 오류 제어(Error Control) 전송 중에 발생하는 오류를 검출하고 정정하여 데이터나 제어 정보의 파손에 대비하는 기능 동기화(Synchronization) 송 수신 측이 같은 상태를 유지하도록 타이밍(Timing)을 맞추는 기능 순서 제어(Sequencing) 전송되는 데이터 블록(PDU)에 전송 순서를 부여하는 기능 연결 위주의 데이터 전송 방식에만 사용 주소 지정(Addressing) 데이터가 목적지까지 정확하게 전송될 수 있도록 목적지 이름, 주소, 경로를 부여하는 기능 다중화(Multplexing) 한 개의 통신 회선을 여러 가입자들이 동시에 사용하도록 하는 기능 경로 제어(Routing) 송 수신 측 간의 송신 경로 중에서 최적의 패킷 교환 경로를 설정하는 기능 전송 서비스 전송하려는 데이터가 사용하도록 하는 별도의 부가 서비스 TCP/IP 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜 TCP 프로토콜과 IP 프로토콜이 결합된 것을 의미 응용 계층, 전송 계층, 인터넷 계층, 네트워크 엑세스 계층으로 이루어져 있다. IP - 네트워크 계층 해당, TCP - 전송 계층 해당 응용 계층의 주요 프로토콜 FTP, SMTP, TELNET, SNMP, DNS, HTTP, MQTT FTP 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜 SMTP 전자 우편을 교환하는 서비스 TELNET 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널 기능을 수행 SNMP TCP/IP의 네트워크 관리 프로토콜로 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는데 사용되는 표준 통신 규약 DNS 도메인 네임을 IP 주소로 매핑하는 시스템 HTTP 월드 와이드 웹(www)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜 MQTT 무선으로 네트워크에 연결된 비교적 단순한 기기들 간의 간단한 소통을 목적으로 만들어진 만큼 리소스를 매우 적게 요구하기 때문에 사물 인터넷에 최적화된 프로토콜 경량성, 이식성, 유연성, 안정성 전송 계층의 주요 프로토콜 TCP, UDP, RTCP TCP [ 신뢰성, 연결 지향적, 흐름 제어, 혼잡 제어 ] 양방향 연결형 서비스를 제공한다. 스트럼 위주의 전달(패킷 단위)을 한다. 신뢰성 있는 경로를 확립하고 메시지 전송을 감독한다. 순서 제어, 오류 제어, 흐름 제어 기능을 한다. TCP 프로토콜의 헤더는 기본적을 20byte~60byte까지 사용 가능하나 선택적으로 40byte를 더 추가 할 수 있어 최대 100byte까지 크기 확장 가능하다. UDP [ 체대소다랭 ] Checksum, Destination, Source Port Number, Data, Length / 아래 참고 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공한다. / 신뢰성 無 TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로 오버헤드가 적고 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다. 실시간 전송에 유리하며 신뢰성보다는 속도가 중요시되는 네트워크에서 사용된다. RTCP 데이터 전송 모니터링, 최소한의 제어와 인증 기능, 32비트 경계로 끝남 RTP 패킷의 전송 품질을 제어하기 위한 제어 프로토콜이다. 세션에 참여한 참여자들에게 주기적으로 제어 정보를 전송한다. 인터넷(네트워크) 계층의 주요 프로토콜 IP 전송할 데이터에 주소를 지정하고 경로를 설정하는 기능을 한다. 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않는다. ICMP IP와 조합하여 통신 중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제어 메시지를 관리하는 역할을 하며 헤더는 8byte로 구성된다. IGMP 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용된다. ARP 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꾼다. RARP ARP와 반대로 물리적 주소를 IP 주소로 반환하는 기능을 한다. 네트워크 엑세스 계층의 주요 프로토콜 Ethernet - IEEE 802.3 CSMA/CD 방식의 LAN IEEE 802 LAN을 위한 표준 프로토콜 802.7 - 미디어 액세스 제어 프로토콜 802.9- ISLAN(Integrated Services LAN) 802.10 - 보안 서비스 802.16 - 광대역 무선 액세스(BWA : Broadband Wireless Access) / 대역폭이 넓은 무선 접속(WiMAX) 802.22 - TV White Space HDLC 비트 위주의 데이터 링크 제어 프로토콜 프레임 구조 순서 플래그 → 주소부 → 제어부 → 정보부 → FCS → 플래그 동작 모드 정규(표준) 응답 모드(NRM), 비동기 응답모드(ARM), 비동기 균형(평형) 모드(ABM ) X.25 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 RS-232C 공중 전화 교환망(PSTN)을 통한 DTE(데이터 단말 장치)와 DCE(데이터 회선 종단 장치) 간의 인터페이스를 제공하는 프로토콜 TCP 포트번호 모뎀 아날로그 회선에서 사용, 디지털 데이터를 아날로그 신호로 변환하거나 그 역의 기능을 함 DSU (Digital Service Unit) - 가입자 측 장비 디지털 회선에 사용, 디지털 데이터를 디지털 신호로 변환 신호의 변복조 방식이 단순하고 저속, 고속 전송 시에 효과적 CSU (Channel Service Unit) - 망 측 장비 T1 및 E1과 같은 트렁크 라인을 그대로 수용할 수 있는 데이터 통신 전용 장비 디지털 트렁크 회선과의 직접 연결에 이용하는 가입자 전송 장치","link":"/2023/06/24/2023/06/1%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A1/"},{"title":"JAVA-연산자-④ 논리, 조건","text":"논리 연산자 2개의 boolean 값의 관계를 비교하여 true, false를 판별한다. boolean : 데이터타입 - boolean(논리형) 연산식 종류 코드 123456789101112131415161718192021222324252627282930boolean a = true;boolean b = false;System.out.println(&quot;true &amp; true = &quot; + (a &amp; a));System.out.println(&quot;true &amp; false = &quot; + (a &amp; b));System.out.println(&quot;false &amp; true = &quot; + (b &amp; a));System.out.println(&quot;false &amp; false = &quot; + (b &amp; b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true &amp;&amp; true = &quot; + (a &amp;&amp; a));System.out.println(&quot;true &amp;&amp; false = &quot; + (a &amp;&amp; b));System.out.println(&quot;false &amp;&amp; true = &quot; + (b &amp;&amp; a));System.out.println(&quot;false &amp;&amp; false = &quot; + (b &amp;&amp; b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true | true = &quot; + (a | a));System.out.println(&quot;true | false = &quot; + (a | b));System.out.println(&quot;false | true = &quot; + (b | a));System.out.println(&quot;false | false = &quot; + (b | b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true || true = &quot; + (a || a));System.out.println(&quot;true || false = &quot; + (a || b));System.out.println(&quot;false || true = &quot; + (b || a));System.out.println(&quot;false || false = &quot; + (b || b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;true ^ true = &quot; + (a ^ a));System.out.println(&quot;true ^ false = &quot; + (a ^ b));System.out.println(&quot;false ^ true = &quot; + (b ^ a));System.out.println(&quot;false ^ false = &quot; + (b ^ b));System.out.println(&quot;------------------------&quot;);System.out.println(&quot;!true = &quot; + !a);System.out.println(&quot;!false = &quot; + !b); 결과 조건 연산자 조건식, true인 경우의 값, false인 경우의 값을 필요로 하여 총 3개의 피연산자가 있는 연산자다. 1조건식 ? true : false 코드 123456789101112131415161718192021222324252627// a는 5라고 정의int a = 5;String b = a % 2 == 0 ? &quot;짝수&quot; : &quot;홀수&quot;;System.out.println(&quot;a는 &quot; + b + &quot;다&quot;);boolean c = a &gt; 3 ? true : false;System.out.println(&quot;a는 3보다 크다. : &quot; + c);// 조건식을 중첩으로 사용할 수도 있다.String d = a % 2 == 0 ? &quot;짝수&quot; : (a % 2 == 1 ? &quot;홀&quot; : &quot;수&quot;); System.out.println(d);// 조건식을 조건문인 IF문으로 변환하여 사용 가능하다.// IF문에서 경우 조건식으로 바꾸어서 사용할 수 도 있다.boolean e;if (a&gt;3) { e = true;} else { e = false;}System.out.println(&quot;a는 3보다 크다. : &quot; + e);// 피연산자의 타입이 다른 경우 자동 타입 변환이 이루어진다.// a가 5보다 큰 경우 1.0 / 아닌경우 0 이지만 변수 f에 0.0이 대입된다.double f = a &gt; 5 ? 1.0 : 0;System.out.println(f); 결과","link":"/2023/07/11/2023/07/JAVA-%EC%97%B0%EC%82%B0%EC%9E%90-%E2%91%A3%20%EB%85%BC%EB%A6%AC,%20%EC%A1%B0%EA%B1%B4/"},{"title":"Node.js - Github Blog","text":"★ 다운로드 링크 ★ Nodejs.org 설치 Add to PATH가 있는 지 확인 빨간 박스 체크 흐름대로 가면 아래와 같이 설치 완료 바탕 화면 - Git Bash Here 아래와 같이 순서대로 진행 - 이후 localhost:4000이 되는지 확인 npm install -g hexo-cli hexo init myblog(파일명) cd myblog/ hexo server 편의를 위해 VS Code이용하기 위해 아래와 같이 진행 Git Bash 창에서 code .입력 _config.yml 파일에서 사용할 url 입력 Github에서 Repository 생성 _config.yml 파일에서 deploy 내용 입력 터미널 열기 Git Bash로 접속 아래의 내용 순서대로 입력 npm install npm install hexo-server —save npm install hexo-deployer-git —save hexo generate hexo deploy 백업 폴더명과 Repository name과 항상 같아야함 / 배포 X 백업 O 차례대로 입력하거나 한번에 입력하여 연동 파일 백업 화면 관리 링크 - https://hexo.io/ko/docs/front-matter 블로그 게시글 올리기 편하게 Notion을 이용해 올리는 방법 다운 받은 파일 압축 풀기 VS Code에서 이미지 경로 입력 Github에 올리기 git add . git commit -m “updated” git push Github 블로그에 배포하기 전 확인 hexo server Github 블로그에 배포하기 hexo generate hexo deploy (배포) hexo generate와 hexo deploy를 합쳐서 hexo d -g 로 사용 가능","link":"/2023/06/22/2023/06/Node.js-Github_Blog/"},{"title":"JAVA-예약어","text":"JAVA에서 사용하는 의미가 약속된 단어들이다. 변수 이름 또는 메서드 이름으로 선언 할 수 없다. 기본 데이터 타입 boolean, byte, int, long, float, double, char, short 접근 지정자 private, protected, public 클래스 관련 class, abstract, interface, extends, implements 등 객체 관련 new, instanceof, this. super, null 등 메소드 관련 void, return 제어문 관련 if, else, switch, break, continue, for, while 등 논리 리터널 true, false 기타 try, catch, finally, throw, true, false 등 참고 자료 : 자바_예약어","link":"/2023/06/26/2023/06/JAVA-%EC%98%88%EC%95%BD%EC%96%B4/"},{"title":"Visual Studio Code 설치 및 환경 설정","text":"코딩 작업 편의를 위한 VS Code 다운로드★ 다운로드 링크 ★ Visual Studio Code 설치 링크 다양한 운영체제에서도 사용 가능 글쓴이는 Window 64bit를 사용하고 있어 x64중 System Installer를 다운 받음 동의 체크 후 다음 원하는 설치 경로 설정 후 다음 클릭(원하는 곳 없으면 그대로 설치해도 무방함) 시작 메뉴 관련 설정 후 다음 클릭 PATH에 추가 : 편의를 위해 체크하는 것을 추천 원하는 것 체크 후 다음 클릭 설치 클릭 설치 완료가 되었으니 Visual Studio Code가 잘 되는 지 실행 Visual Studio Code 실행 체크 후 종료 클릭 실행 화면 플러그 인한국어 설정 사용 시에 영어가 불편하다면 한국어로 설정 가능하다. korean만 입력했을 시 안나올 수도 있기 때문에 language까지 입력 우측 하단에 나오는 창에서 Change Language and Restart 클릭 한국어로 바뀐 것을 볼 수 있다. Live Server 현재 작성한 코드를 실시간으로 로컬 서버로 보여주는 기능. 저장(Ctrl + S)을 하면 실시간으로 웹브라우저에 반영이 된다. 단축키로는 Alt + L 을 입력하고 그 다음에 Alt + O 를 입력해야한다.","link":"/2023/06/18/2023/06/Visual_Studio_Code_Install/"},{"title":"JAVA-변수","text":"변수 하나의 값을 저장하는 메모리 공간 변수를 사용하는 것은 변수에 값을 저장 및 활용하는 것을 의미한다. 변수 선언 변수를 사용하기 위해서는 변수 타입과 변수 이름을 선언해야 한다. 예시 123자료형 변수명;자료형 변수명 = &quot;~~&quot;; or 자료형 변수명 = 10;자료형 변수명1, 변수명2; 코드 1234567int a; // 정수값을 저장할 수 있는 a 변수 선언int b = 5; // 정수값 5를 저장하는 b 변수 선언double c; // 실수값을 저장할 수 있는 c 변수 선언double d = 5.5; // 실수값 5.5를 저장하는 d 변수 선언String e; // 문자열을 저장할 수 있는 e 변수 선언String f = &quot;hello&quot;; // 문자열 &quot;hello&quot; 를 저장하는 f 변수 선언int g, h; // 정수값을 저장할 수 있는 g, h 변수들 선언 변수명 작성 규칙 첫 번째 글자는 문자, $, _ 이어야 하고, 숫자가 될 수 없음 abc, $abc, _abc 영어 대/소문자 구분 Abc와 abc는 서로 다른 문자 관례로 첫 문자는 소문자로 시작, 다른 단어와 혼용할 경우 대문자로 구분 appleBanana 자바 예약어는 사용 불가 참조 : JAVA-예약어 문자 수는 제한 없음","link":"/2023/06/27/2023/06/JAVA-%EB%B3%80%EC%88%98/"},{"title":"JAVA EE &amp; Apche Tomcat 설치","text":"JAVA EE를 사용하기 위한 Eclipse 다운로드★ 다운로드 링크 ★Eclipse Download 아래의 그림에서 이용자의 운영체제에 맞게 선택하여 다운로드 어느 것을 선택하든 같은 것을 다운 받기 때문에 신경 쓰지 않고 다운로드 JDK 설치★ JDK 설치 및 환경 변수 설정 링크 ★ Apache Tomct 다운로드★ 다운로드 링크 ★ : Apache Tomcat® 원하는 버전 선택 ( 글쓴이는 배운 환경과 같은 Tomcat 9를 이용 ) zip 클릭해서 다운로드 다운로드 한 폴더에 그대로 압축 풀기 eclipse 실행 원하는 경로로 설정하고 싶으면 ① Browse 클릭 기본 경로로 만들어서 사용한다면 그대로 ② Launch 클릭 ※ ① Browse 클릭했을 경우 원하는 경로 선택 후 폴더 선택 클릭 경로가 바뀐 것을 볼 수 있다. Launch 클릭하여 Eclipse 실행 아래 그림과 같이 나왔다가 실행이 된다. 작업하기 위한 기본 설정요약 Web -&gt; CSS Files -&gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Web -&gt; HTML Files -&gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Web -&gt; JSP Files -&gt; Encoding : ISO 10646/Unicode(UTF-8) 선택 Server -&gt; Runtime Environments -&gt; Add -&gt; Apache -&gt; Apache 버전 선택 -&gt; Next &gt; Browse &gt; 압축 해제한 Apache Tomcat 폴더 클릭 -&gt; 폴더 선택 클릭 -&gt; Finish 클릭 -&gt; 추가되었는지 확인 -&gt; Apply and Close 클릭 상세 상단의 Window -&gt; Preferences 클릭 ① Web 좌측의 ‘ &gt; ‘ 클릭 → ② CSS Files 좌측의 ‘ &gt; ‘ 클릭 → ③ Korean, EUC-KR클릭 → ④ ISO 10646/Unicode(UTF-8) 을 찾아 클릭 ( 스크롤을 맨 위에 올리면 있음 ) ① Apply 클릭하여 적용 → ② HTML Files 클릭 ① Korean, EUC-KR 클릭 → ②ISO 10646/Unicode(UTF-8) 을 찾아 클릭( 위와 위치 동일함 ) → ③ Apply 클릭하여 적용 → ④ JSP Files 클릭 ① Korean, EUC-KR 클릭 → ②ISO 10646/Unicode(UTF-8) 을 찾아 클릭( 위와 위치 동일함 ) → ③ Apply 클릭 ① Server 좌측의 ‘ &gt; ’ 클릭 → ② Runtime Environments 클릭 → ③ Add.. 클릭 ① Apache 좌측의 ‘ &gt; ’ 클릭 → ② 자신이 받은 Apache Tomcat 버전에 맞게 클릭 → ③ ‘ ② ’를 진행하면 비활성화 되어 있는 Next 버튼이 활성화 되니 Next 클릭 글쓴이는 Apache Tomcat 9를 다운 받았으니 Apache Tomcat v9.0 선택 ① Browse.. 클릭 → 폴더 선택 창이 나옴 → ② 압축 해제한 Apache Tomcat 폴더 클릭 → ③ 폴더 선택 클릭 → ④ 활성화 된 Finish 클릭 추가 되었는지 확인 후 ① Apply and Close 클릭 Test ① Create a Dynamic Web project 클릭 → ② Project name에 원하는 이름 쓰기 → ③ Finish 클릭 ① webapp에서 마우스 오른쪽 클릭 → ② New에 마우스 커서를 놓기 →HTML File이 있다면 클릭 / 없다면 Other.. 클릭 ※ Other.. 클릭 후 ① html 입력하면 ② HTML File 이 자동으로 나옴 → ③ Next 클릭 ① Test.html 입력 → ② Next 클릭 Finish 클릭 예시로 “연동 확인 !!” 입력 ① Test.html 마우스 오른쪽 클릭 → ② Run As에 마우스 커서 놓기 → ③ Run on Server 클릭 ① 자신이 설치한 Tomcat 버전 클릭 (글쓴이는 Tomcat 9 설치) → ② Next 클릭 Project Name인 Test있는지 확인 → Finish 클릭 연동 성공!","link":"/2022/12/27/2022/12/20/JAVA_EE_&_Apche_Tomcat_Install/"},{"title":"JAVA SE 설치","text":"Java SE 를 사용하기 위한 Eclipse 다운로드★ 다운로드 링크 ★Eclipse 다운로드 Download 클릭 Download Packages 클릭 사용자 컴퓨터에 따른 버전 링크 클릭 붉은 박스 클릭해서 다운로드 시작 다운로드 확인 ★ JDK 설치 및 환경 변수 설정 링크 ★","link":"/2022/12/19/2022/12/20/JAVA_SE_Install/"},{"title":"JDK 설치 및 환경 변수 설정","text":"JDK 설치★ 다운로드 링크 ★JDK 설치 Java 17 -&gt; Windows -&gt; 원하는 설치 방식으로 다운로드(zip이 편한 것 같아서 zip을 선택했습니다.) 이와 같이 원하는 폴더 안에 압축해제 환경 변수 설정 내 PC에서 마우스 오른쪽 클릭 후 속성 클릭 고급 시스템 설정 클릭 환경 변수(N)… 클릭 사용자 변수가 아닌 시스템 변수에서 새로 만들기 클릭 변수 이름(N)은 JAVA_HOME 변수 값(V)은 JDK파일을 압축 풀기하고 연 폴더 경로 (글쓴이는 D:\\AI_Class\\tools\\jdk-17.0.4.1의 위치에 있음) 모두 입력 후 확인 JAVA_HOME있는지 확인 / Path 클릭 후 편집 클릭 새로 만들기 클릭 -&gt; D:\\AI_Class\\tools\\jdk-17.0.4.1\\bin 나 %JAVA_HOME%\\bin 중 하나를 쓰시면 됩니다. 이후 확인 누르며 빠져나오기 전부 확인을 눌러 설정 완료 참고 (CLASS PATH) Class Path는 Java Application이 사용하고 있는 Class가 여러 경로로 분산 되어 있을 때 하나로 모으기 위해 사용하는 방법 새로 만들기 클릭 CLASSPATH와 %JAVA_HOME%\\lib 입력 후 확인 설치 확인 시작메뉴 옆에서 cmd 입력 후 명령 프롬프트 실행 java -version 과 javac -version으로 확인 다음과 같이 나오면 설치 완료 java -version에서 오류가 나올 시에는 Eclipse가 제대로 설치가 되어있는지 확인 javac -version에서 오류가 나올 시에는 환경 변수 설정이 잘못되어 있을 가능 성이 높아 환경 변수 설정 확인","link":"/2022/12/19/2022/12/20/JDK_Install/"},{"title":"정보처리 산업기사(2023) 2과목-1장-②","text":"목차 제어문 조건문 반복문 goto 문 배열 포인터 Python 스크립트 언어의 종류 라이브러리 개념 제어문 명령어가 서술된 순서를 변경할 수 있음 if문, 다중 if문, switch문, goto문, 반복문 조건문 프로그램 흐름에 원하는 기준을 조건으로 분기를 추가하여 흐름을 제어 if 문 : JAVA - 조건문 - IF문 switch ~ case 문 : JAVA - 조건문 - Switch ~ Case문 반복문 프로그램 흐름에서 일정 횟수를 반복하고 싶은 구간에 사용하는 제어문 while 문 : JAVA - 반복문 - while문 do ~ while 문 : JAVA - 반복문 - do ~ while문 for 문 : JAVA - 반복문 - for문 goto 문 프로그램 실행 중 현재의 위치에서 원하는 다른 문장으로 이동하여 수행을 계속하기 위해 사용 사용 형식12345goto 레이블;레이블: 실행문; 배열 1차원 배열 : JAVA - 배열 - 1차원 배열 다차원 배열 : JAVA - 배열 - 다차원 배열 포인터 프로그래밍 언어에서 다른 변수, 혹은 그 변수의 메모리 공간주소를 가리키는 변수 C언어에서 사용 사용 예시1234567891011// 포인터 변수 선언자료형 * 변수명;ex) int *a;// 포인터 주소값&amp;변수명;ex) b = &amp;a;// 포인터 변수값*변수명;ex) c = *a; 포인터와 배열 배열 a 와 포인터변수 *a 비교 a[0] a[1] a[2] a[3] a[4] *(a+0) *(a+1) *(a+2) *(a+3) *(a+4) Python슬라이스(Slice) 문자열이나 리스트와 같은 순차형 객체에서 일부를 잘라 반환하는 형식 사용 예시 ①1234567891011# start 인덱스에서 stop-1 인덱스까지 슬라이스객체명 [start : stop]# start 인덱스에서 마지막까지 슬라이스객체명 [start : ]# 처음부터 stop-1 인덱스까지 슬라이스객체명 [ : stop]# 처음부터 마지막 전체 반환객체명 [ : ] 사용 예시 ②1234567891011121314# start 인덱스에서 stop-1 인덱스까지 step값 만큼씩 점프하며 슬라이스객체명 [start : stop : step]# start 인덱스에서 마지막까지 슬라이스객체명 [start : :]# 처음부터 stop-1 인덱스까지 슬라이스객체명 [ : stop : ]# 처음부터 마지막까지 step값 만큼씩 점프하며 슬라이스객체명 [ : : step]# 처음부터 마지막 전체 반환객체명 [ : : ] 스크립트 언어의 종류 자바스크립트 (JAVA Script) 웹페이지 동작 제어, 클라이언트용 스크립트 언어, 객체 지향 프로그래밍 성격을 가짐 VB 스크립트 마이크로소프트 사의 애플리케이션 컨트롤 ASP Windows 계열 수행 가능한 프로그래밍 언어 JSP JAVA 서버용 스크립트 PHP Linux, Unix, Windows 사용 가능, C, JAVA 문법 유사함 Python 귀도 반로섬이 발표한 인터프리터 언어, 객체 지향 기능, 플랫폼 독립적, 문법 간단 쉘 스크립트 Unix/Linux 계열의 쉘에서 사용되는 명령어, 컴파일 단계가 없음, ‘.sh’ 붙음 Bash Shell, Bourne Shell, C shell, Korn Shell 등 선택형 : if, case 반복형 : for, while, until Basic 절차 지향 기능 지원하는 대화형 인터프리터, 초보자도 쉽게 사용할 수 있는 문법 구조 라이브러리 개념 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체 도움말, 설치 파일, 샘플 코드 제공 모듈 : 하나의 기능이 한 개의 파일을 구현된 상태 패키지 : 하나의 패키지 폴더 안에 여러 개의 모듈 C언어의 대표적인 표준 라이브러리 #include &lt;stdio.h&gt; stdio.h : 데이터의 입출력에 사용되는 기능 제공 math.h : 수학 함수들 제공 string.h : 문자열 처리에 사용되는 기능 제공 stdlib.h : 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능을 제공 time.h : 시간 처리에 사용되는 기능 제공","link":"/2023/07/28/2023/07/2%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A1/"},{"title":"정보처리 산업기사(2023) 2과목 - 2장","text":"목차 모듈 프로그래밍 언어 활용2장 프로그램 구현 웹 서버, 웹 애플리케이션 서버, 개발 언어 선정 기준, 프레임 워크, Spring, 제어의 역흐름, 결합도, 응집도, 재사용, API 모듈 개요 모듈화를 통해 분리된 시스템의 각 기능들로, 서브루틴, 서브 시스템, 소프트웨어 내의 프로그램, 작업 단위 등과 같은 의미로 사용됨 모듈의 독립성은 결합도와 응집도에 의해 측정 독립성을 높이려면? 결합도 ↓, 응집도 ↑, 모듈의 크기 ↓ 모듈의 응집도는 높고 결합도는 낮은 설계가 이상적 모듈의 내부 구조가 각 요소들이 서로 연관되어 있으면서도 모듈 간의 의존성이 적은 구조가 바람직 결합도 (Coupling) [ 자 스 제 외 공 내 ] 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미한다. 결합도 ↑ → 독립성 ↓ → 의존성 ↑ → 설계의 품질 ↓ 결합도 약 → 강 ( 결합도가 약할수록 모듈의 독립성 ↑ ) 자료 결합도 (Data Coupling) 다른 모듈 호출하면서 매개 변수나 인수로 데이터를 넘겨주고 처리 결과를 다시 돌려주는 방식 스탬프(검인) 결합도 (Stamp Coupling) 두 모듈이 동일한 자료 구조를 조회하는 경우의 결합도 자료 구조의 어떠한 변화, 즉 포맷이나 구조의 변화는 그것을 조회하는 모든 모듈 및 변화되는 필드를 실제로 조회하지 않는 모듈에 까지도 영향을 미친다. 제어 결합도 (Control Coupling) 한 모듈이 다른 모듈의 상세한 처리 절차를 알고 있어 이를 통제하는 경우나 처리 기능이 두 모듈에 분리되어 설계된 경우에 발생 외부 결합도 (Exernal Coupling) 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 공통(공유) 결합도 (Common Coupling) 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 내용 결합도 (Content Coupling) 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 응집도 (Cohesion) [ 우 논 시 절 통 순 기 ] 응집도는 정보 은닉 개념을 확장한 것으로, 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도, 즉 모듈이 독립적인 기능으로 정의되어 있는 정도를 의미합니다. 응집도 약 → 강 ( 응집도가 약할 수록 품질 ↓ , 독립성 ↓) 우연적 응집도 (Coincidental Cohesion) 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도 논리적 응집도 (Logical Cohesion) 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도 시간적 응집도 (Temporal Cohesion) 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도 절차적 응집도 (Procedural Cohesion) 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도 교환(통신)적 응집도 (Communication Cohesion) 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도 순차적 응집도 (Sequential Cohesion) 모듈 내 하나의 활동으로 부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 기능적 응집도 (Functional Cohesion) 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 팬인 (Fan-In) / 팬아웃 (Fan-Out) 팬인 : 제어하는 모듈의 수 (화살표가 들어오는 개수) 팬아웃 : 제어되는 모듈의 수 (화살표가 나가는 개수) 복잡도를 최적화 하려면 팬인 ↑, 팬아웃 ↓ 소프트웨어 개발 보안의 개요 개발 과정에서 발생할 수 있는 보안 취약점을 최소화하여 보안 위협으로부터 안전한 소프트웨어를 개발하기 위한 일련의 보안 활동 보안 요소 [ 부 인 무 기 가 ] 부인 방지, 인증, 무결성 오직 인가 된 사용자만 수정 기밀성 인가 된 사용자 접근 허용, 노출되면 읽을 수 없음 가용성 인가 받은 사용자는 언제라도 사용 가능","link":"/2023/07/29/2023/07/2%EA%B3%BC%EB%AA%A9-2%EC%9E%A5/"},{"title":"정보처리 산업기사(2023) 3과목 - 1장 - ①","text":"목차 데이터 베이스 이해 자료 구조 자료 구조 분류 데이터 베이스 이해 스택, 트리, 정렬, 데이터 베이스, 데이터 모델, E-R모델, 관계형 데이터 베이스, 키, 정규화, 뷰 자료 구조 저장 공간의 효율성과 실행 시간의 신속성을 위한 자료 간의 관계, 처리 방법들을 연구 분석하는 것 논리적 관점 데이터 사이의 관계와 조작 방법을 기술한 추상 자료형(Abstract Data Type)으로 정의 프로그램에서 사용되는 데이터와 해당 데이터를 조작하기 위한 함수나 연산들의 집합으로 구성 물리적 관점 데이터가 메모리에 저장되는 방식 (접근하는 방식에 따라 다양한 자료 구조 존재) ex) 배열, Linked List 자료 구조 분류 선형 구조 배열 동일한 자료형의 데이터들이 같은 크기로 나열되어 순서를 갖는 집합 데이터 삭제 시 메모리 낭비 발생 선형 리스트(Linear List) ( 연속 리스트(배열), 연결 리스트(포인터) ) 일정한 순서에 의해 나열된 자료 구조 연속 리스트 배열과 같이 연속되는 기억 장소에 저장되는 자료 구조 기억 장소를 연속적으로 배정 받기 때문에 기억 장소 이용 효율은 밀도가 1로서 가장 좋다. 삽입 및 삭제 시 자료의 이동이 필요 연결 리스트 자료들을 반드시 연속적으로 배열시키지는 않고 임의의 기억 공간에 기억 시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결 시킨 자료 구조 노드의 삽입, 삭제 작업이 용이 기억 공간이 연속적으로 놓여 있지 않아도 저장할 수 있다. 스택(Stack) 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO) 방식으로 자료를 처리 용도 재귀 호출, 후위 표기법, 서브루틴 호출, 인터럽트 처리, 깊이 우선 탐색 등과 같이 왔던 길을 되돌아가는 경우에 사용 모든 기억 공간이 꽉 채워져 있는 상태에서 데이터가 삽입되면 오버플로우가 발생, 더 이상 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로우가 발생 용어 삽입 (Push), 삭제 (Pop), 읽기 (Peek) Bottom : 가장 밑바닥, 먼저 들어온 데이터 위치 Top : 스택의 포인터 위치 or 가장 마지막에 들어온 데이터 위치 큐(Queue) 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조 가장 먼저 삽입된 자료가 가장 먼저 삭제되는 선입선출 (FIFO) 방식으로 처리 용어 Enqueue : 데이터 입력하는 함수 Dequeue : 데이터 출력하는 함수 Peek : front에 위치한 데이터를 읽음 front (f) : 가장 먼저 들어온 데이터 공간 rear (r) : 가장 마지막에 들어온 데이터 공간 덱(Deque) ( = 양방향 큐 ) 삽입과 삭제가 리스트 양쪽 끝에서 모두 발생 할 수 있는 자료 구조 ( FIFO, LIFO 가능) 스택과 큐의 장점만 따서 구성 비선형 구조 **정점(Node,노드)**과 **선분(Branch,가지)**을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태 노드 (Node) : 하나의 기억 공간 링크 (Link) : 노드와 노드 사이를 연결하는 선 용어 노드 (Node) 트리를 구성하고 있는 기본 요소로서 자료 항목과 다른 항목에 대한 브랜치를 합친 것 근 노드 (Root Node) 트리 구조에서 부모가 없는 최상위 노드 디그리 (Degree) 각 노드에서 뻗어 나온 가지 수 단말 노드 (Terminal Node) = 잎 노드 (Leaf Node) 자식이 하나도 없는 노드 ( Degree가 0인 노드) 자식 노드 (Son Node) 어떤 노드에 연결된 하위(다음) 레벨의 노드들 부모 노드 (Parent Node) 어떤 노드에 연결된 상위(이전) 레벨의 노드들 형제 노드 (Brother Node, Siblings) 동일한 부모를 갖는 노드들 트리의 디그리(degree) 노드들의 디그리 중에서 가장 많은 수 트리의 운행법 트리를 구성하는 각 노드들을 찾아가는 방법 이진 트리를 운행하는 방법은 산술식 표기법과 연관성을 갖음 Preorder 운행 (전위 순회) Root → Left → Right 순회 경로 : A - B - D - H - I - E - J - K - C - F - L - G Inorder 운행 (중위 순회) Left → Root → Right Postorder 운행 (후위 순회) Left → Right → Root 수식의 표기법 산술식을 계산하기 위해 기억 공간에 기억시키는 방법 전위 표기법 (PreFix) : 연산자 → Left → Right 중위 표기법(InFix) : Left → 연산자 → Right 후위 표기법(PostFix) : Left → Right → 연산자 그래프(Graph) 방향 그래프의 최대 간선 수 : n(n-1) 무방향 그래프의 최대 간선 수 : n(n-1)/2","link":"/2023/07/31/2023/07/3%EA%B3%BC%EB%AA%A9-1%EC%9E%A5-%E2%91%A0/"},{"title":"JAVA - 객체지향프로그래밍","text":"목차 객체 지향 프로그래밍 객체 객체 지향 프로그래밍 언어 객체 지향 프로그래밍 특징 추상화 캡슐화 상속 다형성 객체 지향 프로그래밍의 장단점 장점 단점 객체 지향 프로그래밍 Object-Oriented Programming로 약자는 OOP다. 컴퓨터 프로그래밍의 패러다임 중 하나로 실세계에 존재하는 객체를소프트웨어의 세계에서 표현하기 위해 객체의 핵심적인 개념 또는 기능만을추출하는 추상화를 통해 객체를 만들어, 그 객체들 간의 유기적인 상호작용을 통해로직을 구성하는 프로그래밍이다. 객체 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신과 다른 것을 식별 가능한 것 참고 : JAVA - 객체 객체 지향 프로그래밍 언어 사용 언어 : C++, C#, Java, Python, JavaScript 등이 있다. 참고 : 객체 지향 언어 객체 지향 프로그래밍 특징추상화 공통된 속성과 행위를 모아 추출하는 것 불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 프로그램을 간단히 만드는 것 공통의 속성과 행위를 찾아서 타입을 정의하는 과정 예시) SUV, 세단, 버스 등의 공통된 속성과 행위를 모아 “자동차” 라는 객체를 만든다. 캡슐화 객체의 속성(필드) 과 행위(메서드)를 하나로 묶어내고, 실제 구현 내용은 외부에 감추는 것이다. 외부에 대한 접근을 차단하여 객체가 손상되지 않도록 한다. 낮은 결합도를 유지할 수 있도록 설계 캡슐화 된 멤버의 노출 여부를 접근 제한으로 관리한다. 상속 부모가 가지고 있는 기능을 자식에게 물려준다.→ 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능 코드 재활용 가능, 유지보수 편의성 제공 다형성 어떤 한 요소에 여러 개념을 넣어 놓는 것이다. 객체를 부품화 할 수 있고, 유지보수가 용이하다. 예시 오버라이딩 하위 클래스가 상위 클래스에서 만들어진 메서드를 원하는 방향으로 재정립하여 사용 오버로딩 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는 것 객체 지향 프로그래밍의 장단점장점 클래스를 재사용하거나 상속하는 것을 통해 코드의 재사용성이 용이 클래스 단위로 모듈화 하여 업무 분담이 가능하기 때문에 생산성 향상됨 클래스 단위로 모듈화가 되어 있어 유지 보수의 용이성이 높음 단점 설계에 많은 시간과 노력이 소요 처리 속도가 느림 객체 수가 많아져 용량이 커질 수 있음","link":"/2023/08/01/2023/08/JAVA-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"title":"JAVA - 생성자","text":"목차 생성자 특징 기본 생성자와 매개 변수가 있는 생성자 주의 사항 생성자 객체가 생성될 때 자동으로 호출되어 인스턴스 변수를 지정한 값으로 초기화하는 메소드즉, 인스턴스 초기화 메소드이다. 특징 생성자의 이름은 클래스의 이름과 동일해야 한다. 클래스 내에서 선언되며 리턴 값이 없고 상속되지 않는다. 리턴 값이 없다고 반환 타입 void를 선언하지 않는다. 하나의 클래스가 여러개의 생성자를 가질 수 있다. 생성자도 메소드이므로 메소드 오버로딩이 가능 기본 생성자와 매개 변수가 있는 생성자 하나의 클래스에는 반드시 하나 이상의 생성자가 존재해야 한다. 코드 작성자가 생성자를 구현하지 않을 경우에는 컴파일러가 자동으로 생성자 코드를 넣는다. 생성자 오버로딩이 가능하여 여러 개의 생성자를 사용할 수 있다. 예시 12345678910111213접근제어자 class 클래스명 { 자료형(String, int, ...) 변수명; // 기본 생성자 - 생략 가능 접근제어자 클래스명() { } // 매개 변수가 있는 생성자 - 생략 불가능 접근제어자 클래스명(자료형 매개변수①, 자료형 매개변수②, ...) { ~~~ ~~~ } 접근제어자 리턴타입(String, int, ...) 메소드명(){ } } 접근제어자 : Depra3’s JAVA - 접근제어자 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Car { String model; int speed; // 필드를 직접적으로 초기화할 수도 있다. String color = &quot;빨강&quot;; // 기본 생성자 public Car() { // 생략 가능. 만들어놓지 않아도 기본은 존재. } // 생성자 오버로딩 public Car(String model){ // 매개변수가 하나인 생성자 this.model = model; // 입력받은 매개변수 값을 객체 변수에 입력 } // 생성자 오버로딩 public Car(String model, int speed){ // 매개 변수가 2개인 생성자 this.model = model; this.speed = speed; this.color = color; } public void carInfo() { // 출력 System.out.println(&quot;제조사 : &quot; + model + &quot;, 속도 : &quot; + speed); } public void carColor() { System.out.println(&quot;자동차 색상 : &quot; + color); }}----------------------------------------public class test { public static void main(String[] args) { Car car1 = new Car(); // 객체 생성 - 기본 생성자 Car car2 = new Car(&quot;BMW&quot;); // 객체 생성 - 매개 변수 1개인 생성자 Car car3 = new Car(&quot;BMW&quot;, 120); // 객체 생성 - 매개 변수 2개인 생성자 car1.carInfo(); // 기본 생성자 car2.carInfo(); // 매개 변수 1개인 생성자 car3.carInfo(); // 매개 변수 2개인 생성자 car3.carColor(); }} 실행 결과 주의 사항 기본 생성자는 생략할 수 있다. 그러나 기본 생성자를 정의하지 않고 다른 생성자 정의가 1개 이상이 존재하는 상태에서 기본 생성자 호출하면 다음과 같은 Error가 발생한다. 코드 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Car { String model; int speed; // 필드를 직접적으로 초기화할 수도 있다. String color = &quot;빨강&quot;; // 기본 생성자// public Car() { // // 생략 가능. 만들어놓지 않아도 기본은 존재// } // 생성자 오버로딩 public Car(String model){ // 매개변수가 하나인 생성자 this.model = model; // 입력받은 매개변수 값을 객체 변수에 입력 } // 생성자 오버로딩 public Car(String model, int speed){ // 매개 변수가 2개인 생성자 this.model = model; this.speed = speed; this.color = color; } public void carInfo() { // 출력 System.out.println(&quot;제조사 : &quot; + model + &quot;, 속도 : &quot; + speed); } public void carColor() { System.out.println(&quot;자동차 색상 : &quot; + color); }}----------------------------------------public class test { public static void main(String[] args) { Car car1 = new Car(); // 객체 생성 - 기본 생성자 ★ Error 발생 ★ Car car2 = new Car(&quot;BMW&quot;); // 객체 생성 - 매개 변수 1개인 생성자 Car car3 = new Car(&quot;BMW&quot;, 120); // 객체 생성 - 매개 변수 2개인 생성자 car1.carInfo(); // 기본 생성자 car2.carInfo(); // 매개 변수 1개인 생성자 car3.carInfo(); // 매개 변수 2개인 생성자 car3.carColor(); }} 실행 결과","link":"/2023/08/02/2023/08/JAVA-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"title":"JAVA - 메소드","text":"목차 메소드 특징 사용 목적 기본 구조 메소드 종류 ① 입력과 출력이 있는 메소드 ② 입력이 있지만 출력은 없는 메소드 ③ 입력이 없지만 출력이 있는 메소드 ④ 입력과 출력이 없는 메소드 메소드 멤버 함수 (member function) 라고도 하며 객체 지향 프로그래밍에서 객체와 관련된 서브 루틴 ( 또는 함수) 이자 클래스가 갖고 있는 기능이다. 데이터와 멤버 변수에 대한 접근 권한을 갖는다. 특징 메소드의 이름은 생성자와는 다르게 임의로 지정할 수 있다. 하나의 클래스가 여러 개의 메소드를 가질 수 있다. 메소드 오버로딩을 이용하여 중복된 메소드명을 가진 메소드들을 가질 수 있다. 사용 목적 중복되는 코드 사용을 줄여 반복적인 프로그래밍을 피할 수 있다. 모듈화로 인해 코드 가독성이 향상된다. 모듈화로 인해 유지 보수가 수월해진다. 기본 구조 매개 변수 : 메소드에 전달된 입력 값을 저장하는 변수 12345접근제어자 리턴타입(String, int, ...) 메소드명(자료형 매개변수①, 자료형 매개변수②, ...){ ~~ ~~ return 리턴 값; // 단, 리턴타입이 void인 경우 return은 사용할 필요가 없다.} 접근제어자 : Depra3’s JAVA - 접근제어자 메소드 종류① 입력과 출력이 있는 메소드 매개 변수 a, b를 입력 받아 int형 a+b값을 return한다. 코드 123456789int sum(int a, int b){ return a + b;}public static void main(String[] args) { Test test = new Test(); int sum = test.sum(1, 2); System.out.println(&quot;a와 b의 합 : &quot; + sum);} 결과 ② 입력이 있지만 출력은 없는 메소드 매개 변수 a, b를 입력 받지만 return이 없다. 출력값이 없어 메소드 자료형을 void로 한다. 코드 12345678void sum(int a, int b){ System.out.println(&quot;a와 b의 합 : &quot; + (a + b));}public static void main(String[] args) { Test test = new Test(); test.sum(1, 2);} 결과 ③ 입력이 없지만 출력이 있는 메소드 입력 받는 매개 변수가 없으나 String형 return값인 world을 출력한다. 코드 123456789String hello(){ return &quot;world&quot;; // 리턴 값이 문자열이기 때문에 String 리턴 타입을 사용}public static void main(String[] args) { Test test = new Test(); String re = test.hello(); System.out.println(re);} 결과 ④ 입력과 출력이 없는 메소드 입력 값과 출력값이 없다.출력값이 없어 메소드 자료형을 void로 한다. 코드 12345678void hello(){ System.out.println(&quot;world&quot;);}public static void main(String[] args) { Test test = new Test(); test.hello();} 결과","link":"/2023/08/04/2023/08/JAVA-%EB%A9%94%EC%86%8C%EB%93%9C/"},{"title":"JAVA - 접근제어자","text":"목차 접근제어자 특징 종류 public protected default private 접근 범위 접근제어자 클래스 or 클래스 멤버(필드, 메소드 생성자)를 사용할 때, 접근할 수 있는 범위를 지정하는 역할 생략이 가능하며, 생략할 때는 자동적으로 default로 설정된다. 특징 접근을 제어하여 외부에 의한 접근으로부터 데이터를 보호한다. 객체지향 프로그래밍에서 캡슐화하기 위한 기능으로 사용된다. 종류public 접근 제한이 없어 모든 접근이 가능클래스, 클래스 멤버 모두 사용 예시 1234public class Test(){ // 클래스 public int a; // 클래스 멤버 public String b;} protected 같은 패키지 내의 모든 클래스, 다른 패키지의 자식 클래스에서 접근 가능클래스 멤버만 사용 예시 1234public class Test(){ // 클래스 protected int a; // 클래스 멤버 protected String b;} default 같은 패키지 내에서만 접근 가능클래스, 클래스 멤버 모두 생략해서 사용 예시 1234class Test(){ // 클래스 int a; // 클래스 멤버 String b;} private 같은 클래스 내에서만 접근 가능클래스 멤버만 사용 예시 1234public class Test(){ // 클래스 private int a; // 클래스 멤버 private String b;} 접근 범위 접근 범위 : public &gt; protected &gt; default &gt; private","link":"/2023/08/07/2023/08/JAVA-%EC%A0%91%EA%B7%BC%EC%A0%9C%EC%96%B4%EC%9E%90/"},{"title":"JAVA - static","text":"목차 Static 특징 사용 목적 Static 멤버 선언 ※ 주의 사항 ※ Static ‘정적인’, ‘고정된’ 이란 의미를 가지고 있으며 Static 키워드를 사용하여 변수와 메소드를 만들 수 있다. 이 static 변수, static 메소드를 다른 말로 정적 필드와 정적 메소드라고도 하며 합쳐서 정적 멤버 또는 클래스 멤버라고 한다. 특징 어떤 객체 또는 인스턴스에 소속되지 않고 클래스에 고정된 멤버이다.따라서 클래스 로더가 클래스를 로딩하면 클래스와 같이 메모리 영역에 할당되어 관리된다.이로 인해 클래스의 로딩이 끝나는 즉시 사용할 수 있다. 동일 클래스 내에서 모든 객체(인스턴스)에서 공유하여 사용한다. 클래스 당 하나만 생성되며 클래스 멤버라고도 부른다. static 메소드 안에서 static 멤버들만 사용 가능하다. 사용 목적 모든 클래스에서 호출이 가능한 전역변수 또는 전역함수를 만들어서 사용하기 위함 static 변수는 동일 클래스 내에서 모든 객체(인스턴스)에서 공유가 가능하여 필요할 때 사용한다. Static 멤버 선언 예시 12345678910// 정적 필드 선언static 자료형 변수명;static 자료형 변수명 = ~~;// 정적 메소드 선언접근제어자 static 자료형 리턴타입 메소드명(){}// 예시public static int sta_field = 0; // 정적 필드 선언public static void sta_method(){} // 정적 메소드 선언 사용 예시 123456789101112131415public class Test { public static int sta_field1 = 123; public int sta_field2 = 456;}--------------------------------------------------public class Exam { public static void main(String[] args) { System.out.println(Test.sta_field1); Test t2 = new Test(); System.out.println(t2.sta_field2); }} 결과 ※ 주의 사항 ※ 오류 코드 1234567891011121314public class Test { public static int sta_field1 = 123; public int sta_field2 = 456;}--------------------------------------------------public class Exam { public static void main(String[] args) { System.out.println(Test.sta_field1); System.out.println(Test.sta_field2); }} Test 클래스에서 변수 sta_field2는 정적 변수로 선언하지 않아 오류 발생 결과 정적 변수는 클래스 로더가 클래스를 로딩하면 같이 메모리가 할당되기 때문에 객체 생성을 하지 않아도 사용이 가능하다. 정적 변수 선언을 하지 않으면 메모리에 할당이 되지 않아 객체 생성하기 전에 호출할 수 없는 것 같다.","link":"/2023/08/09/2023/08/JAVA-static/"},{"title":"JAVA - final - ①","text":"목차 final 특징 사용 목적 final 변수 ★ 오류 발생 ① ★ final 메소드 ★ 오류 발생 ② ★ final 사전적 의미로 ‘결정적인’, ‘마지막의’로 쓰인다.자바에서는 사전적 의미와 같이 초기값이 결정되면 최종 결정이 되어 더 이상 값을 수정할 수 없다. 특징 변수, 메소드, 클래스, 객체에 사용이 가능하다. 변수에 사용하면 재할당이 불가능하여 수정이 불가능하다. 메소드에 사용하면 메소드 오버라이딩이 불가능하다. 클래스에 사용하면 해당 클래스는 상속할 수 없다. 따라서, 자식 클래스를 만들지 못 한다. 객체 생성에 사용하면 해당 객체는 같은 타입으로 재생성이 불가능하다.그러나 객체 내부 변수는 수정이 가능하다. 사용 목적 변하지 말아야하는 싶은 변수, 메소드, 클래스가 있다면 final을 사용하여 코딩 시에 예상치 못한 수정이 되거나 하는 상황 없이 마음 편안하게 코딩할 수 있다. final 변수 변수를 고정값으로 선언할 때 사용한다. 예시 123456// 형식 ①final 자료형 변수명;변수명 = ~~;// 형식 ②final 자료형 변수명 = ~~; 코드 12345final int a;a = 1;final String b = &quot;Depra3&quot;;System.out.println(a);System.out.println(b); 결과 ★ 오류 발생 ① ★ final 변수에 재할당 시에 오류 발생 코드 결과 final 메소드 final 메소드는 변경을 원치 않는 메소드를 선언할 때 사용한다.메소드 오버라이딩이 불가능하여 오버라이딩 한다면 오류가 발생한다. 예시 1접근제어자 final 리턴타입 메소드명(){ } 코드 12345678910111213141516public class Test { String a = &quot;Depra3&quot;; public final void show() { System.out.println(a); }}------------------------------------public class Exam { public static void main(String[] args) { Test t11 = new Test(); t11.show(); }} 결과 ★ 오류 발생 ② ★ final 메소드에 오버라이딩 시에 오류 발생 코드 12345678910111213141516171819202122public class Test { String a = &quot;Depra3&quot;; public final void show() { System.out.println(a); }}------------------------------------public class Test1 extends Test { String a = &quot;Depra2&quot;; public void show() { // 메소드 오버라이딩 오류 발생 System.out.println(&quot;Depra3 = &quot; a); }}------------------------------------public class Exam { public static void main(String[] args) { Test1 t11 = new Test1(); t11.show(); }} 결과","link":"/2023/08/10/2023/08/JAVA-final-%E2%91%A0/"},{"title":"JAVA - final - ②","text":"목차 final 특징 사용 목적 final 클래스 ★ 오류 발생 ① ★ final 객체 ★ 오류 발생 ② ★ 메소드 인자값에 final 사용 ★ 오류 발생 ③ ★ final 사전적 의미로 ‘결정적인’, ‘마지막의’로 쓰인다.자바에서는 사전적 의미와 같이 초기값이 결정되면 최종 결정이 되어 더 이상 값을 수정할 수 없다. 특징 변수, 메소드, 클래스, 객체, 인자값에 사용이 가능하다. 변수에 사용하면 재할당이 불가능하여 수정이 불가능하다. 메소드에 사용하면 메소드 오버라이딩이 불가능하다. 클래스에 사용하면 해당 클래스는 상속할 수 없다. 따라서, 자식 클래스를 만들지 못 한다. 메소드의 인자값에 사용하면 해당 인자값은 수정할 수 없다. 객체 생성에 사용하면 해당 객체는 같은 타입으로 재생성이 불가능하다.그러나 객체 내부 변수는 수정이 가능하다. 사용 목적 변하지 말아야하는 싶은 변수, 메소드, 클래스, 인자값이 있다면 final을 사용하여 코딩 시에 예상치 못한 수정이 되거나 하는 상황 없이 마음 편안하게 코딩할 수 있다 final 클래스 final 클래스는 상속할 수 없는 클래스다.Setter를 이용해 클래스 필드를 재할당 할 수 있다. 예시 1접근제어자 final class 클래스명 { } 코드 12345678910111213141516171819202122232425public final class Test { String a = &quot;Depra3&quot;; public void show() { System.out.println(a); } // getter / setter public String getA() { return a; } public void setA(String a) { this.a = a; }}----------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(); t1.show(); t1.setA(&quot;Depra&quot;); t1.show(); }} 결과 ★ 오류 발생 ① ★ final 클래스는 상속할 수 없는 클래스이기에 상속 시에 에러 발생 코드 12345678910111213141516171819202122public final class Test { String a = &quot;Depra3&quot;; public void show() { System.out.println(a); }}----------------------------------public class Test1 extends Test { String a = &quot;Depra2&quot;; public void show() { System.out.println(&quot;Depra3 = &quot; + a); }}----------------------------------public class Exam { public static void main(String[] args) { Test1 t1 = new Test1(); t1.show(); }} 에러 발생 위치 결과 final 객체 객체 생성에 사용하면 해당 객체는 같은 타입으로 재생성이 불가능하다.그러나 객체 내부 변수는 수정이 가능하다. 예시 1final 클래스명 객체명 = new 클래스명(); 코드 1234567891011121314public final class Test { String a = &quot;Depra3&quot;; public void show() { System.out.println(a); }}----------------------------------public class Exam { public static void main(String[] args) { final Test t1 = new Test(); t1.show(); }} 결과 ★ 오류 발생 ② ★ 객체 생성에 사용하면 해당 객체는 같은 타입으로 재생성이 불가능하여 재할당을 하면 에러가 발생한다. 코드 123456789101112131415public final class Test { String a = &quot;Depra3&quot;; public void show() { System.out.println(a); }}----------------------------------public class Exam { public static void main(String[] args) { final Test t1 = new Test(); t1 = new Test(); t1.show(); }} 에러 발생 위치 결과 메소드 인자값에 final 사용 인자값에 final을 사용하면 final 인자값의 수정은 불가능하다. 예시 1접근제어자 리턴타입 메소드명(final 자료형 변수명){ } 코드 1234567891011121314public class Test { public final void show(final String a) { System.out.println(a); }}------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(); t1.show(&quot;Depra3's result&quot;); }} 결과 ★ 오류 발생 ③ ★ 받은 인자값을 수정하려 하면 오류 발생 코드 123456789101112131415public class Test { public final void show(final String a) { a = &quot;Depra3&quot;; System.out.println(a); }}------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(); t1.show(&quot;Depra3's result&quot;); }} 오류 발생 위치 결과","link":"/2023/08/11/2023/08/JAVA-final-%E2%91%A1/"},{"title":"JAVA - 패키지 와 import","text":"목차 패키지 특징 패키지 이름 짓는 규칙 import 패키지 클래스를 구분, 체계적으로 관리하기 위한 폴더 우리가 사용하는 eclipse 프로그램에서 볼 수 있는 패키지의 위치 클래스를 생성하면 보이는 패키지 선언 방식 특징 하나의 소스 파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다. 모든 클래스는 하나의 패키지에 속해야 한다. 물리적으로 클래스 파일(.class)을 포함하는 하나의 디렉토리다. 점(.)을 구분자로 하여 계층 구조로 구성할 수 있다. ex) java.lang 패키지에서 lang은 java의 하위 패키지다. 클래스와 인터페이스를 포함할 수 있으며, 관련 클래스 및 인터페이스들끼리 그룹 단위로 묶을 수 있다. 패키지 이름 짓는 규칙 숫자로 시작 금지 ‘_’ 와 ‘$’ 를 제외한 특수 문자 사용 금지 자바 표준 API에서 사용하는 java로 시작하는 패키지 이름 금지 String, int 등 자바 예약어 금지 예약어 : Depra3’s JAVA - 예약어 모두 소문자로 작성하는 것이 관례 import 컴파일러에게 클래스가 속한 패키지를 알려준다. 클래스를 사용할 때, 패키지 명을 생략하여 사용이 가능하다. 다른 패키지 안의 클래스를 사용하기 위해서 해당 클래스 이름 앞에 패키지명과 (.)을 붙여야한다. 선언 방식 1234567891011121314import 패키지명.클래스명;import 패키지명.*; // * 로 생략이 가능하다. ( * 는 모든 클래스 포함을 의미 )// ↓ ↓ ↓import java.util.Date;// util 패키지 아래의 클래스 사용 빈도가 높은 경우 *을 이용해 한 줄로 사용 가능하다.import java.util.*;---------------------// * 가 모든 클래스를 의미하기 때문에 util 패키지가 포함되지 않는다.import java.*;","link":"/2023/08/14/2023/08/JAVA-%ED%8C%A8%ED%82%A4%EC%A7%80%EC%99%80import/"},{"title":"JAVA - Getter &#x2F; Setter 메소드","text":"목차 Getter와 Setter 메소드 Getter Setter Getter와 Setter의 메소드 선언 객체 무결성을 보호하는 방법 Getter와 Setter 메소드 객체 지향 프로그래밍에서 캡슐화를 이용해 데이터에 대한 직접적인 접근을 차단한다.그 이유는 객체 무결성을 지키기 위함이다.객체에서 음수가 들어가면 안되는 변수에 직접적으로 음수를 넣으면 객체의 무결성이 깨진다.때문에 객체의 무결성을 보호하며 데이터를 변경하는 방법인 Getter/Setter 메소드를 사용한다. Getter 객체 내부의 멤버 변수에 저장된 값을 외부로 리턴한다. 매개 변수가 없고 리턴이 있다. 메소드명은 get + 변수명으로 사용한다. 변수명 첫글자는 대문자로 한다. Setter 객체 내부의 멤버 변수에 데이터를 전달하여 저장한다. 매개 변수가 있고 리턴이 없다. 메소드명은 set + 변수명으로 사용한다. 변수명 첫글자는 대문자로 한다. Getter와 Setter의 메소드 선언 예시 123456789private 자료형 변수명;public 리턴타입 get+변수명() { return 변수명;}public void set+변수명(자료형 변수명) { this.변수명 = 변수명;} 코드 1234567891011121314151617181920public class Test { private int a; public int getA() { return a; } public void setA(int a) { this.a = a; }}------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(); t1.setA(-1); System.out.println(t1.getA()); }} 결과 객체 무결성을 보호하는 방법객체 무결성 객체가 손상되지 않고 완전성, 정확성, 일관성을 유지하는 특성 코드 1234567891011121314151617181920212223public class Weight { private int kg; public int getKg() { return kg; } public void setKg(int kg) { if (kg &lt; 0) { this.kg = 0; } else { this.kg = kg; } }}-----------------------------------public class Exam { public static void main(String[] args) { Weight w1 = new Weight(); w1.setKg(-10); System.out.println(&quot;w1객체의 몸무게의 값 : &quot; + w1.getKg()); }} 결과 w1.setKg()메소드에서 -10을 매개변수로 입력했지만 몸무게는 음수가 될 수 없기에 조건을 설정하여 음수가 입력되면 0으로 저장하도록 했다.","link":"/2023/08/16/2023/08/JAVA-GetterSetter%EB%A9%94%EC%86%8C%EB%93%9C/"},{"title":"JAVA - 싱글톤패턴","text":"목차 싱글톤 패턴 특징 사용 예제 싱글톤 패턴 문제점 싱글톤 패턴 소프트웨어 디자인 패턴 중의 하나다. 객체의 인스턴스가 단 1개만 생성되는 패턴이다. 객체를 static 키워드를 사용하여 정적 메모리(static)에 할당한다. 접근제어자에 private로 설정하여 상속이 불가능하다. 특징 하나의 인스턴스만을 사용한다. 생성된 객체 하나만을 활용하여 사용하기 때문에 재사용이 가능하여 메모리의 낭비를 방지한다. 객체가 정적 메모리에 할당이 되기 때문에 전역성을 가지게 되어 다른 객체 간의 공유가 쉽다. 사용 예제 코드 12345678910111213141516171819202122232425262728293031323334public class SingletonTest { private static SingletonTest instance = new SingletonTest(); private int a = 0; private SingletonTest() { } public static SingletonTest getInstance() { return instance; } public int getA() { return a; } public void setA(int a) { this.a = a; }}----------------------------------------------------public class Exam { public static void main(String[] args) { SingletonTest s1 = SingletonTest.getInstance(); System.out.println(&quot;s1.a = &quot; + s1.getA()); System.out.println(&quot;--------------------&quot;); // a값 수정 s1.setA(10); System.out.println(&quot;s1.a = &quot; + s1.getA()); SingletonTest s2 = SingletonTest.getInstance(); System.out.println(&quot;s2.a = &quot; + s2.getA()); }} 결과 싱글톤 패턴의 특징으로 객체를 재생성해도 처음 생성했던 객체가 리턴된다. s1 객체에서 값을 수정했지만 s2 객체에서도 같은 값을 공유하는 모습이 보인다. 싱글톤 패턴 문제점1. 테스트가 어렵다. 싱글톤의 객체에 대한 의존성이 있는 클래스를 테스트 할 때 싱글톤이 전역 상태를 유지하기 때문에 싱글톤의 객체 상태가 다른 테스트의 영향을 받는다. 2. 내부 상태를 변경하기 어렵다. 싱글톤 객체는 하나의 값을 공유하기 때문에 한 쪽에서 수정하면 다른 쪽도 같이 값이 바뀌어 상황에 유연하게 대처하기 어렵다. 3. 객체 의존성이 높다. 싱글톤의 객체는 전역 상태이기 떄문에 다른 객체들이 싱글톤 객체를 의존하는 경우에 객체 간의 결합도가 높아질 수 있다. 높아지는 결합도로 인해 코드 유지보수가 어렵고 객체의 재사용성이 떨어질 수 있다.","link":"/2023/08/21/2023/08/JAVA-%EC%8B%B1%EA%B8%80%ED%86%A4%ED%8C%A8%ED%84%B4/"},{"title":"JAVA - 상속 - CLASS","text":"목차 상속 특징 상속 선언 참고 키워드 상속 기존 클래스(상위/부모 클래스)의 필드와 메소드를 다른 클래스(하위 클래스)가 이어받아 사용할 수 있게 하는 기능이다. 다형성, 캡슐화, 추상화와 같이 객체 지향 프로그래밍을 구성하는 특징 중 하나다. 객체 지향 프로그래밍 : JAVA - 객체 지향 프로그래밍 클래스는 extends, 인터페이스는 implements 키워드를 사용하여 구현한다. 클래스는 다중 상속 불가, 인터페이스는 다중 상속 가능 특징 기존 클래스(상위/부모 클래스)의 변수와 메소드를 재사용할 수 있어 개발 시간이 단축된다. 클래스 간 계층적 분류 및 관리가 가능하여 유지보수에 용이하다. 상속 선언 예시 1234567class 클래스명(기존, 상위) { ...}----------------------------------class 클래스명(하위) extends 상위 클래스명{ ...} 코드 12345678910111213141516171819202122232425262728293031323334class Test { String name; int number; public void tPrint() { System.out.println(&quot;Hello World!&quot;); }}---------------------------------------------------------class Test1 extends Test { String loc; Test1(String name, int number, String loc) { super.name = name; super.number = number; this.loc = loc; } @Override public void tPrint() { System.out.println(&quot;name = &quot; + name); System.out.println(&quot;number = &quot; + number); System.out.println(&quot;loc = &quot; + loc); }}---------------------------------------------------------public class Exam { public static void main(String[] args) { Test1 t1 = new Test1(&quot;Depra3&quot;, 1, &quot;A1&quot;); t1.showInfo(); // 오버라이딩된 메소드 호출 t1.tPrint(); // 상위(부모) 클래스 메소드 호출 }} 메소드 오버라이딩 : JAVA - 메소드 결과 참고 키워드 참고 이미지 super 키워드 하위 or 자식 클래스에서 상위 or 부모 클래스를 가리킬 때 사용하는 키워드이다. 상위 or 부모 클래스의 필드와 메소드에 접근할 때 사용한다. this 키워드 하위 or 자식 클래스의 객체에서 객체 자기 자신을 참조할 때 사용한다.","link":"/2023/08/22/2023/08/JAVA-%EC%83%81%EC%86%8D-CLASS/"},{"title":"JAVA - 상속 - Interface","text":"목차 상속 특징 상속 선언 이중 상속 다중 상속 선언 상속 기존 클래스(상위/부모 클래스)의 필드와 메소드를 다른 클래스(하위 클래스)가 이어받아 사용할 수 있게 하는 기능이다. 다형성, 캡슐화, 추상화와 같이 객체 지향 프로그래밍을 구성하는 특징 중 하나다. 객체 지향 프로그래밍 : JAVA - 객체 지향 프로그래밍 클래스는 extends, 인터페이스는 implements 키워드를 사용하여 구현한다. 클래스는 다중 상속 불가, 인터페이스는 다중 상속 가능 특징 인터페이스의 변수와 메소드를 재사용할 수 있어 개발 시간이 단축된다. 클래스와 인터페이스 간 계층적 분류 및 관리가 가능하여 유지보수에 용이하다. 상속 선언 클래스와 인터페이스 간의 상속은 implements 키워드를 사용한다. 예시 1234567interface 인터페이스명 { ...}----------------------------------class 클래스명(하위) implements 인터페이스명{ ...} 코드 123456789101112131415161718192021222324252627282930313233interface InterfaceTest { public void showName(); public void showNumber();}---------------------------------------------------------class Test implements InterfaceTest { String name; int number; public Test(String name, int number) { this.name = name; this.number = number; } @Override public void showName() { System.out.println(&quot;name : &quot; + name); } @Override public void showNumber() { System.out.println(&quot;number = &quot; + number); }}---------------------------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(&quot;Depra3&quot;, 5); t1.showName(); // 오버라이딩된 메소드 호출 t1.showNumber(); // 오버라이딩된 메소드 호출 }} 메소드 오버라이딩 : JAVA - 메소드 결과 이중 상속 인터페이스간의 상속은 extends 키워드를 사용한다. 예시 1234567891011interface 인터페이스명1 { ...}----------------------------------interface 인터페이스명2 extends 인터페이스명1 { ...}----------------------------------class 클래스명(하위) implements 인터페이스명2 { ...} 코드 123456789101112131415161718192021222324252627282930313233343536interface InterfaceTest2 { public void showNumber();}---------------------------------------------------------interface InterfaceTest1 extends InterfaceTest2{ public void showName();}---------------------------------------------------------class Test implements InterfaceTest1 { String name; int number; public Test(String name, int number) { this.name = name; this.number = number; } @Override public void showName() { System.out.println(&quot;name : &quot; + name); } @Override public void showNumber() { System.out.println(&quot;number = &quot; + number); }}---------------------------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(&quot;Depra3&quot;, 15); t1.showName(); // 오버라이딩된 메소드 호출 t1.showNumber(); // 오버라이딩된 메소드 호출 }} 결과 다중 상속 선언 implements 키워드 뒤에 나열하여 사용한다. 예시 1234567891011interface 인터페이스명1 { ...}----------------------------------interface 인터페이스명2 { ...}----------------------------------class 클래스명(하위) implements 인터페이스명1, 인터페이스명2 { ...} 코드 123456789101112131415161718192021222324252627282930313233343536interface InterfaceTest1 { public void showName();}---------------------------------------------------------interface InterfaceTest2 { public void showNumber();}---------------------------------------------------------class Test implements InterfaceTest1, InterfaceTest2 { String name; int number; public Test(String name, int number) { this.name = name; this.number = number; } @Override public void showName() { System.out.println(&quot;name : &quot; + name); } @Override public void showNumber() { System.out.println(&quot;number = &quot; + number); }}---------------------------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(&quot;Depra3&quot;, 10); t1.showName(); // 오버라이딩된 메소드 호출 t1.showNumber(); // 오버라이딩된 메소드 호출 }} 결과","link":"/2023/08/23/2023/08/JAVA-%EC%83%81%EC%86%8D-Interface/"},{"title":"JAVA - 추상클래스 (Abstract Class)","text":"목차 추상 클래스 (Abstract Class) 특징 사용 목적 사용 예제 추상 클래스 (Abstract Class) 하나 이상의 추상 메소드를 포함하는 클래스추상 메소드를 선언하고, 자식 클래스에서 메소드를 완성하도록 하는 클래스다.따라서, 미완성 설계도라고도 불린다. 특징 객체 지향 프로그래밍에서 중요한 특징인 다형성을 가지는 메소드의 집합을 정의할 수 있도록 한다. 반드시 사용되어야 하는 메소드를 추상 클래스에서 선언해 놓으면, 이 클래스를 상속 받는 모든 클래스에서 해당하는 추상 클래스를 반드시 재정의를 ****해야한다. 상속을 위한 클래스이므로 인스턴스를 따로 생성할 수 없다. ( new 생성 불가) 사용 목적① 공통된 필드와 메소드를 통일 중복으로 사용하는 필드와 메소드를 제거하여 유지보수가 편하다. ② 구현의 강제성을 이용한 기능 보장 해당 프로그램의 기능에 필요한 메소드들을 잊고 코딩하지 않는다면 나중에 문제가 생길 수도 있다. 그러나 추상 클래스를 상속받는다면 해당 클래스의 메소드들을 전부 구현해야하기 때문에 기능들을 보장받을 수 있다. ③ 규격에 맞는 설계 구현 존재하는 제품을 개발자 마음대로 구현한다면 불량(에러)이 생길 수도 있기 때문에 해당 제품의 설계서에 따른 규격에 맞게 구현해야 한다. 사용 예제 예시 123456abstract class 클래스명{ 접근제어자 자료형 변수명; 접근제어자 abstract 리턴타입 메소드명(); 접근제어자 리턴타입 메소드명(); ...} 코드 1234567891011121314151617181920212223242526272829303132333435363738abstract class AbTest { public int currentSpeed; public AbTest(int speed) { // 기본 생성자 this.currentSpeed = speed; } public void drive() { System.out.println(&quot;전진&quot;); } public void stop() { System.out.println(&quot;정지&quot;); } public abstract void bbang(); // 자동차 경적음 추상 메소드화}----------------------------------------class Test extends AbTest { // 추상 클래스 상속 public Test(int speed) { // 기본 생성자 // super 키워드로 추상 클래스 기본 생성자 이용 super(speed); } public void showInfo() { System.out.printf(&quot;Car의 현재 속도 : %d \\n&quot;, this.currentSpeed); } @Override public void bbang() { // 추상 클래스 메소드를 상속받아 오버라이딩 System.out.println(&quot;빠----앙!!&quot;); // 자동차 경적음 지정 }}----------------------------------------public class Exam { public static void main(String[] args) { Test tCar = new Test(100); tCar.drive(); tCar.showInfo(); tCar.bbang(); tCar.stop(); }} 결과","link":"/2023/08/26/2023/08/JAVA-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4(Abstract%20Class)/"},{"title":"JAVA - 인터페이스 (Interface)","text":"목차 인터페이스 특징 사용 목적 사용 예제 Interface-상속 인터페이스 (Interface) 클래스에서 특정한 기능(메소드)들을 모아 구현하도록 강제하는 기능이 있다. 특징 추상 메소드와 상수로 이루어져 있다. 생성자를 생성할 수 없다. 다중 상속이 가능하다. 상속 받은 클래스(하위)는 부모 인터페이스(상위)의 메소드들 모두 메소드 오버라이딩해야 한다. 사용 목적① 공통된 기능을 하는 메소드를 통일 중복으로 기능하는 메소드들의 네이밍을 통일하여 소스 가독성과 유지보수가 편하다. ② 구현의 강제성을 이용한 기능 보장 해당 프로그램의 기능에 필요한 메소드들을 잊고 코딩하지 않는다면 나중에 문제가 생길 수도 있다. 그러나 인터페이스를 상속받는다면 메소드들을 전부 구현하여야 하므로 기능을 보장할 수 있다. 사용 예제 예시 1234567interface 인터페이스명 { public 자료형 변수명 = 0; public static 자료형 변수명 = &quot;&quot;; public static final 자료형 변수명 = &quot;&quot;; public void 메소드명(); public abstract void 메소드명();} 코드 12345678910111213141516171819202122232425interface InterfaceTest { public static final String a = &quot;Interface - Test&quot;; public void show(); public abstract void view();}-------------------------------------class Test implements InterfaceTest { @Override public void show() { System.out.println(&quot;Show!!&quot;); } @Override public void view() { System.out.println(&quot;View!!&quot;); }}-------------------------------------public class Exam { public static void main(String[] args) { Test t1 = new Test(); System.out.println(t1.a); t1.show(); t1.view(); }} 결과 Interface 상속 참조 링크 : Depra3’s JAVA - Interface 상속","link":"/2023/08/28/2023/08/JAVA-Interface/"},{"title":"JAVA - 예외(Exception) 정의 및 종류","text":"목차 예외 ㅡ Exception 예외 종류 1. Nullpointerexception 2. ArrayIndexOutOfBoundsException 3. NumberFormatException 4. ClassCastException 예외 ㅡ Exception 프로그램에 대한 사용자의 조작 또는 개발자의 코딩에서 문제가 발생하여 생기는 오류 에러와 같이 문제가 발생하면 프로그램은 곧바로 종료가 되지만, 예외는 처리를 통해 실행 상태가 정상이 되도록 할 수 있다. 예외 종류1. NullPointerException 객체 참조가 없는 상태에서 메서드를 호출할 때 발생 ① 객체 생성 후 객체가 가리키는 heap주소를 null로 변경할 경우 코드 1234567891011121314151617181920212223public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(&quot;달리다.&quot;); }}---------------------------------------public class Exam { public static void main(String[] args) { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); h1.run(); h1 = null; System.out.println(h1); h1.run(); // NullpointException }} 결과 ② 배열 변수에 null로 초기화 한 후 배열 내의 값을 접근할 경우 코드 123456public class Exam { public static void main(String[] args) { int[] arr = null; System.out.printf(&quot;intValue[0] = %d\\n&quot;, arr[0]); // NullpointException }} 결과 2. ArrayIndexOutOfBoundsException 배열에서 인덱스 범위를 초과하여 사용할 경우 발생 코드 12345678public class Exam { public static void main(String[] args) { int[] arr = { 10, 20, 30 }; System.out.printf(&quot;arr[0] = %d\\n&quot;, arr[0]); System.out.printf(&quot;arr[2] = %d\\n&quot;, arr[2]); System.out.printf(&quot;arr[3] = %d\\n&quot;, arr[3]); // ArrayIndexOutOfBoundsException }} 결과 3. NumberFormatException 문자열을 숫자로 변환하는 경우 주로 발생 숫자로 변환할 수 없는 문자가 포함되어 있는 경우 코드 1234567891011121314public class Exam { public static void main(String[] args) { String str1 = &quot;1000&quot;; int int1 = Integer.parseInt(str1); int intplus1 = int1 + 10; System.out.printf(&quot;intplus1 : %d \\n&quot;, intplus1); String str2 = &quot;a1000&quot;; int int2 = Integer.parseInt(str2); // NumberFormatException // str2는 숫자로 변환할 수 없는 형태이므로 Exception발생 int intplus2 = int2 + 10; System.out.printf(&quot;intplus2 : %d \\n&quot;, intplus2); }} Integer.parseInt() 는 문자열을 숫자로 변환하는 함수다. 결과 4. ClassCastException 타입 변환이 되지 않을 때 발생 코드 123456789101112131415161718192021222324252627282930313233343536373839404142public class Animal { public Animal() { System.out.println(&quot;animal 객체 생성&quot;); }}--------------------------------------public class Cat extends Animal { public Cat() { super(); System.out.println(&quot;Cat 객체 생성&quot;); } public void run() { System.out.println(&quot;고양이가 뛰어다니다.&quot;); }}--------------------------------------public class Dog extends Animal { public Dog() { super(); System.out.println(&quot;Dog 객체 생성&quot;); } public void run() { System.out.println(&quot;강아지가 뛰어다니다.&quot;); }}--------------------------------------public class AnimalExam { public static void main(String[] args) { // 상속관계에서의 자동타입변환 Animal animal = new Dog(); // 강제타입변환 Dog d1 = (Dog) animal; d1.run(); // 강제타입변환 Cat c1 = (Cat) animal; // ClassCastException c1.run(); }} 결과","link":"/2023/08/31/2023/08/JAVA-%EC%98%88%EC%99%B8(Exception)_%EC%A0%95%EC%9D%98_%EB%B0%8F_%EC%A2%85%EB%A5%98/"},{"title":"JAVA - 예외처리 (try ~ catch ~ finally 문)","text":"목차 예외 ㅡ Exception try ㅡ catch ㅡ finally문 사용 예제 ① 사용 예제 ② 예외 ㅡ Exception 프로그램에 대한 사용자의 조작 또는 개발자의 코딩에서 문제가 발생하여 생기는 오류 정의 및 종류 : Depra3’s JAVA - 예외(Exception) 정의 및 종류 try ㅡ catch ㅡ finally문try 블록 예외가 발생할 가능성이 있는 코드들을 묶는다. catch 블록 예외가 발생하면 처리하는 코드들을 묶는다. 발생하는 예외 종류에 따라 매개변수로 설정하여 종류에 따른 예외 처리를 할 수 있다. 어디서 예외가 발생했는지 알기 위해 로그를 남기기도 한다. finally 블록 예외 발생 유무에 상관없이 무조건 실행하는 코드들을 묶는다. 생략이 가능하다. 사용 예제 ① 예외 종류에 맞게 catch 블록에서 매개변수로 받아 사용 예시 1234567try { 예외가 발생할 가능성이 있는 코드들} catch(예외 종류){ 예외가 발생하면 처리하는 코드들} finally{ // 생략 가능 예외 상관없이 무조건 실행하는 코드들} 코드 1234567891011121314151617181920212223242526272829303132333435public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(&quot;달리다.&quot;); }}---------------------------------------public class Exam { public static void main(String[] args) { try { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); h1.run(); h1 = null; System.out.println(h1); h1.run(); // NullpointerException 예외 발생 } catch (NullPointerException ne) { System.out.println(); System.out.println(&quot;예외 발생!! Catch 블록 실행!!&quot;); System.out.println(&quot;ne : &quot; + ne); System.out.println(ne.getStackTrace()); System.out.println(ne.getMessage()); } finally { System.out.println(); System.out.println(&quot;Finally 블록 실행!!&quot;); } }} 결과 사용 예제 ② 예외 발생 종류와 상관 없이 catch 블록에서 Exception 클래스 객체를 매개변수로 받아 사용 코드 1234567891011121314151617181920212223242526272829303132333435public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(&quot;달리다.&quot;); }}---------------------------------------public class Exam { public static void main(String[] args) { try { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); h1.run(); h1 = null; System.out.println(h1); h1.run(); // NullpointerException } catch (Exception e) { System.out.println(); System.out.println(&quot;예외 발생!! Catch 블록 실행!!&quot;); System.out.println(&quot;e : &quot; + e); System.out.println(e.getStackTrace()); System.out.println(e.getMessage()); } finally { System.out.println(); System.out.println(&quot;Finally 블록 실행!!&quot;); } }} 결과","link":"/2023/09/03/2023/09/JAVA-%EC%98%88%EC%99%B8%EC%B2%98%EB%A6%AC(try~catch~finally)/"},{"title":"JAVA - 예외 발생 및 처리 (throw, throws)","text":"목차 예외 ㅡ Exception throw throws 예외 ㅡ Exception 프로그램에 대한 사용자의 조작 또는 개발자의 코딩에서 문제가 발생하여 생기는 오류 정의 및 종류 : Depra3’s JAVA - 예외(Exception) 정의 및 종류 예외 처리 : Depra3’s JAVA - 예외처리 (try ~ catch ~ finally) throw 억지로 에러를 발생시키고자 할 때 사용되거나 현재 메소드의 에러를 처리한 후 상위 메소드에 에러 정보를 넘겨 상위 메서드에서도 에러가 발생한 것을 감지하게 함 예시 12345678910try { 예외가 발생할 가능성이 있는 코드들 throw new 예외 종류(&quot;~~ 예외 발생시 보내질 메시지 ~~&quot;); // 예외 발생} catch(예외 종류){ 예외가 발생하면 처리하는 코드들 System.out.println(e.getMessage()); // 메시지 받아서 출력} finally{ // 생략 가능 예외 상관없이 무조건 실행하는 코드들} 코드 12345678910111213141516171819202122232425262728293031323334353637383940public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(&quot;달리다.&quot;); }}---------------------------------------public class Exam { public static void main(String[] args) { try { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); h1.run(); h1 = null; System.out.println(h1); // 코드 추가 if (h1 == null) { throw new NullPointerException(&quot;객체 h1가 존재하지 않습니다.&quot;); // 예외 발생 } System.out.println(&quot;객체 h1 가 달리다.&quot;); h1.run(); // NullpointException } catch (NullPointerException ne) { System.out.println(); System.out.println(&quot;예외 발생!! Catch 블록 실행!!&quot;); System.out.println(ne.getStackTrace()); System.out.println(ne.getMessage()); System.out.println(ne); } ****finally { System.out.println(); System.out.println(&quot;Finally 블록 실행!!&quot;); } }} 결과 **Depra3’s JAVA - 예외처리 (try ~ catch ~ finally) 글의 사용 예제 ① 과는 다른 결과를 볼 수 있다** throws 현재 메서드에서 예외가 발생하면 해결하지 않고 자신을 호출한 상위 메서드로 예외를 전가시킴 예시 12345678910111213141516public static void main(String[] args) { try { 예외가 발생할 가능성이 있는 코드들 func(); } catch(Exception e){ 예외가 발생하면 처리하는 코드들 System.out.println(e.getMessage()); // 메시지 받아서 출력 } finally{ // 생략 가능 예외 상관없이 무조건 실행하는 코드들 }}--------------------------------------------public static void func() throws Exception { throw new 예외 종류(&quot;~~ 예외 발생시 보내질 메시지 ~~&quot;); // 예외 발생} 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(&quot;달리다.&quot;); }}---------------------------------------public class Exam { public static void main(String[] args) { try { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); h1.run(); h1 = null; System.out.println(h1); // 코드 추가 if (h1 == null) { func(); } System.out.println(&quot;객체 h1 가 달리다.&quot;); h1.run(); // NullpointException } catch (NullPointerException ne) { System.out.println(); System.out.println(&quot;예외 발생!! Catch 블록 실행!!&quot;); System.out.println(ne.getStackTrace()); System.out.println(ne.getMessage()); System.out.println(ne); } ****finally { System.out.println(); System.out.println(&quot;Finally 블록 실행!!&quot;); } } public static void func() throws NullPointerException { throw new NullPointerException(&quot;객체 h1가 존재하지 않습니다.&quot;); // 예외 발생 }} 결과 방식을 바꾸어 코드가 throw와 다르지만 결과가 같은 것을 볼 수 있다.","link":"/2023/09/20/2023/09/JAVA-%EC%98%88%EC%99%B8%EB%B0%9C%EC%83%9D%EB%B0%8F%EC%B2%98%EB%A6%ACthrow,throws/"},{"title":"JAVA - Object클래스 와 메서드종류 ①","text":"목차 Object 클래스 메서드 종류 toString() 메서드 hashCode() 메서드 Object 클래스 모든 클래스들의 최상위 클래스모든 클래스들은 상속하지 않아도 기본적으로 java.lang 패키지에 속한 Object클래스를 상속받고 Object클래스에 속한 메서드들을 사용할 수 있다. 메서드 종류toString() 메서드 toString() 메서드는 객체를 문자열로 표현된 정보값으로 반환한다. 예시 1234567// Object 클래스에 정의되어 있는 메서드 코드public String toString() { return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());}----------------// 사용 예시객체.toString(); 코드 123456789public static void main(String[] args) { Object obj = new Object(); Date date = new Date(); System.out.println(obj.toString()); System.out.println(date.toString()); // Date라는 클래스 안에는 toString이 오버라이딩이 되어 있다. // 그래서 날짜 형식으로 출력이 된다.} 결과 hashCode() 메서드 해시코드는 객체를 식별하는 하나의 정수 값을 말한다. 따라서, hashCode() 메서드는 객체의 해시코드를 반환한다. 예시 12345// Object 클래스에 정의되어 있는 메서드 코드public native int hashCode();----------------// 사용 예시객체.hashCoode(); hashCode() 메서드의 내용이 없는 것처럼 보인다. 그러나 C언어로 작성한 native함수로 정의되어있는 것 같다. 자세한 설명은 링크를 참고. 코드 1234567891011121314151617181920public class Human { public String name; public Human(String name) { this.name = name; } public void run() { System.out.println(this.name + &quot;이(가) 달리다.&quot;); }}---------------------public class Exam { public static void main(String[] args) { Human h1 = new Human(&quot;Depra3&quot;); System.out.println(h1); // 객체 h1의 주소 System.out.println(h1.hashCode()); }} 결과","link":"/2023/09/23/2023/09/JAVA-Object%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EB%A9%94%EC%84%9C%EB%93%9C%EC%A2%85%EB%A5%98%E2%91%A0/"},{"title":"JAVA - Object클래스 와 메서드종류 ②","text":"목차 Object 클래스 getClass() 메서드 Object 클래스 모든 클래스들의 최상위 클래스모든 클래스들은 상속하지 않아도 기본적으로 java.lang 패키지에 속한 Object클래스를 상속받고 Object클래스에 속한 메서드들을 사용할 수 있다. getClass() 메서드 객체의 클래스 정보를 알 수 있는 메서드로 Class타입의 객체로 정보를 담아 반환한다. 정보를 가지고 있는 Class타입의 객체는 클래스 정보에 접근 할 수 있는 메소드들을 가지고 있다. getName() : 해당 객체의 클래스의 이름을 반환하는 메서드 getSuperclass() : 해당 객체의 상위 클래스의 이름을 반환하는 메서드 getDeclaredFields() : 해당 객체의 클래스에서 선언되어있는 멤버 변수명들을 배열로 반환하는 메서드 getDeclaredMethods() : 해당 객체의 클래스에 선언되어 있는 멤버 함수명들을 배열로 반환하는 메서드 나머지 메서드들 보는 법 아래 이미지와 같이 “ . “을 입력하면 사용할 수 있는 메서드들이 보인다. 예시 1234567 Object 객체명1 = new Object(); Class 객체명2 = 객체명1.getClass(); // 객체명2에 객체명1의 클래스 정보를 담는다.객체명2.getName();객체명2.getSuperclass();객체명2.getDeclaredFields();객체명2.getDeclaredMethods();... 코드 12345678910111213141516171819202122232425262728293031323334public class Human { public String name; public int age; public int height; public int weight; public Human(String name, int age, int height, int weight) { this.name = name; this.age = age; this.height = height; this.weight = weight; } public void run() { System.out.println(this.name + &quot;이(가) 달리다.&quot;); }}-----------------------------------------public static void main(String[] args) { Human h1 = new Human(&quot;Depra3&quot;, 1, 2, 3); Class c1 = h1.getClass(); // Class 객체 c1에 객체 h1의 클래스 정보를 담는다. System.out.println(c1.getName()); // 객체 c1에 담긴 클래스 이름 출력 Field[] f1 = c1.getDeclaredFields(); for (int i = 0; i &lt; f1.length; i++) { System.out.println(&quot;멤버 필드 &quot; + i + &quot; : &quot; + f1[i]); } // 멤버 변수 출력 Method[] m1 = c1.getDeclaredMethods(); for (int i = 0; i &lt; m1.length; i++) { System.out.println(&quot;멤버 메서드 &quot; + i + &quot; : &quot; + m1[i]); } // 멤버 함수 출력} 결과","link":"/2023/09/25/2023/09/JAVA-Object%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80%EB%A9%94%EC%84%9C%EB%93%9C%EC%A2%85%EB%A5%98%E2%91%A1/"}],"tags":[{"name":"JAVA EE","slug":"JAVA-EE","link":"/tags/JAVA-EE/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"JAVA Spring","slug":"JAVA-Spring","link":"/tags/JAVA-Spring/"},{"name":"정보처리 산업기사","slug":"정보처리-산업기사","link":"/tags/%EC%A0%95%EB%B3%B4%EC%B2%98%EB%A6%AC-%EC%82%B0%EC%97%85%EA%B8%B0%EC%82%AC/"},{"name":"개념","slug":"개념","link":"/tags/%EA%B0%9C%EB%85%90/"},{"name":"객체","slug":"객체","link":"/tags/%EA%B0%9D%EC%B2%B4/"},{"name":"객체의 속성","slug":"객체의-속성","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%86%8D%EC%84%B1/"},{"name":"객체의 기능","slug":"객체의-기능","link":"/tags/%EA%B0%9D%EC%B2%B4%EC%9D%98-%EA%B8%B0%EB%8A%A5/"},{"name":"메서드","slug":"메서드","link":"/tags/%EB%A9%94%EC%84%9C%EB%93%9C/"},{"name":"멤버 변수","slug":"멤버-변수","link":"/tags/%EB%A9%A4%EB%B2%84-%EB%B3%80%EC%88%98/"},{"name":"필드","slug":"필드","link":"/tags/%ED%95%84%EB%93%9C/"},{"name":"반복문","slug":"반복문","link":"/tags/%EB%B0%98%EB%B3%B5%EB%AC%B8/"},{"name":"do~while문","slug":"do-while문","link":"/tags/do-while%EB%AC%B8/"},{"name":"foreach문","slug":"foreach문","link":"/tags/foreach%EB%AC%B8/"},{"name":"while문","slug":"while문","link":"/tags/while%EB%AC%B8/"},{"name":"배열","slug":"배열","link":"/tags/%EB%B0%B0%EC%97%B4/"},{"name":"다차원 배열","slug":"다차원-배열","link":"/tags/%EB%8B%A4%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4/"},{"name":"For문","slug":"For문","link":"/tags/For%EB%AC%B8/"},{"name":"연산자","slug":"연산자","link":"/tags/%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"증감 연산자","slug":"증감-연산자","link":"/tags/%EC%A6%9D%EA%B0%90-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"관계(비교) 연산자","slug":"관계-비교-연산자","link":"/tags/%EA%B4%80%EA%B3%84-%EB%B9%84%EA%B5%90-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"1차원 배열","slug":"1차원-배열","link":"/tags/1%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4/"},{"name":"조건문","slug":"조건문","link":"/tags/%EC%A1%B0%EA%B1%B4%EB%AC%B8/"},{"name":"IF문","slug":"IF문","link":"/tags/IF%EB%AC%B8/"},{"name":"산술 연산자","slug":"산술-연산자","link":"/tags/%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"부호 연산자","slug":"부호-연산자","link":"/tags/%EB%B6%80%ED%98%B8-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"문자열 연산자","slug":"문자열-연산자","link":"/tags/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"대입 연산자","slug":"대입-연산자","link":"/tags/%EB%8C%80%EC%9E%85-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"클래스","slug":"클래스","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"인스턴스","slug":"인스턴스","link":"/tags/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"데이터 타입","slug":"데이터-타입","link":"/tags/%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85/"},{"name":"Switch~Case문","slug":"Switch-Case문","link":"/tags/Switch-Case%EB%AC%B8/"},{"name":"논리 연산자","slug":"논리-연산자","link":"/tags/%EB%85%BC%EB%A6%AC-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"조건 연산자","slug":"조건-연산자","link":"/tags/%EC%A1%B0%EA%B1%B4-%EC%97%B0%EC%82%B0%EC%9E%90/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"예약어","slug":"예약어","link":"/tags/%EC%98%88%EC%95%BD%EC%96%B4/"},{"name":"VS Code","slug":"VS-Code","link":"/tags/VS-Code/"},{"name":"변수","slug":"변수","link":"/tags/%EB%B3%80%EC%88%98/"},{"name":"Apache Tomcat","slug":"Apache-Tomcat","link":"/tags/Apache-Tomcat/"},{"name":"JAVA SE","slug":"JAVA-SE","link":"/tags/JAVA-SE/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"객체 지향 프로그래밍","slug":"객체-지향-프로그래밍","link":"/tags/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"캡슐화","slug":"캡슐화","link":"/tags/%EC%BA%A1%EC%8A%90%ED%99%94/"},{"name":"상속","slug":"상속","link":"/tags/%EC%83%81%EC%86%8D/"},{"name":"다형성","slug":"다형성","link":"/tags/%EB%8B%A4%ED%98%95%EC%84%B1/"},{"name":"추상화","slug":"추상화","link":"/tags/%EC%B6%94%EC%83%81%ED%99%94/"},{"name":"장점","slug":"장점","link":"/tags/%EC%9E%A5%EC%A0%90/"},{"name":"단점","slug":"단점","link":"/tags/%EB%8B%A8%EC%A0%90/"},{"name":"생성자","slug":"생성자","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"생성자 오버로딩","slug":"생성자-오버로딩","link":"/tags/%EC%83%9D%EC%84%B1%EC%9E%90-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/"},{"name":"기본 생성자","slug":"기본-생성자","link":"/tags/%EA%B8%B0%EB%B3%B8-%EC%83%9D%EC%84%B1%EC%9E%90/"},{"name":"Error","slug":"Error","link":"/tags/Error/"},{"name":"메소드","slug":"메소드","link":"/tags/%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"메소드 오버로딩","slug":"메소드-오버로딩","link":"/tags/%EB%A9%94%EC%86%8C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/"},{"name":"접근 제어자","slug":"접근-제어자","link":"/tags/%EC%A0%91%EA%B7%BC-%EC%A0%9C%EC%96%B4%EC%9E%90/"},{"name":"접근 제한자","slug":"접근-제한자","link":"/tags/%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90/"},{"name":"public","slug":"public","link":"/tags/public/"},{"name":"protected","slug":"protected","link":"/tags/protected/"},{"name":"default","slug":"default","link":"/tags/default/"},{"name":"private","slug":"private","link":"/tags/private/"},{"name":"클래스 로더","slug":"클래스-로더","link":"/tags/%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%8D%94/"},{"name":"정적변수","slug":"정적변수","link":"/tags/%EC%A0%95%EC%A0%81%EB%B3%80%EC%88%98/"},{"name":"static","slug":"static","link":"/tags/static/"},{"name":"함수","slug":"함수","link":"/tags/%ED%95%A8%EC%88%98/"},{"name":"final","slug":"final","link":"/tags/final/"},{"name":"패키지","slug":"패키지","link":"/tags/%ED%8C%A8%ED%82%A4%EC%A7%80/"},{"name":"import","slug":"import","link":"/tags/import/"},{"name":"객체 무결성","slug":"객체-무결성","link":"/tags/%EA%B0%9D%EC%B2%B4-%EB%AC%B4%EA%B2%B0%EC%84%B1/"},{"name":"Getter","slug":"Getter","link":"/tags/Getter/"},{"name":"Setter","slug":"Setter","link":"/tags/Setter/"},{"name":"소프트웨어 디자인 패턴","slug":"소프트웨어-디자인-패턴","link":"/tags/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4/"},{"name":"싱글톤 패턴","slug":"싱글톤-패턴","link":"/tags/%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/"},{"name":"특징","slug":"특징","link":"/tags/%ED%8A%B9%EC%A7%95/"},{"name":"문제점","slug":"문제점","link":"/tags/%EB%AC%B8%EC%A0%9C%EC%A0%90/"},{"name":"객체 단 1개","slug":"객체-단-1개","link":"/tags/%EA%B0%9D%EC%B2%B4-%EB%8B%A8-1%EA%B0%9C/"},{"name":"super","slug":"super","link":"/tags/super/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"extends","slug":"extends","link":"/tags/extends/"},{"name":"다중 상속","slug":"다중-상속","link":"/tags/%EB%8B%A4%EC%A4%91-%EC%83%81%EC%86%8D/"},{"name":"implements","slug":"implements","link":"/tags/implements/"},{"name":"추상 클래스","slug":"추상-클래스","link":"/tags/%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"추상 메소드","slug":"추상-메소드","link":"/tags/%EC%B6%94%EC%83%81-%EB%A9%94%EC%86%8C%EB%93%9C/"},{"name":"미완성 설계도","slug":"미완성-설계도","link":"/tags/%EB%AF%B8%EC%99%84%EC%84%B1-%EC%84%A4%EA%B3%84%EB%8F%84/"},{"name":"오버라이딩","slug":"오버라이딩","link":"/tags/%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9/"},{"name":"abstract","slug":"abstract","link":"/tags/abstract/"},{"name":"Error(오류)","slug":"Error-오류","link":"/tags/Error-%EC%98%A4%EB%A5%98/"},{"name":"예외","slug":"예외","link":"/tags/%EC%98%88%EC%99%B8/"},{"name":"종류","slug":"종류","link":"/tags/%EC%A2%85%EB%A5%98/"},{"name":"NullPointerException","slug":"NullPointerException","link":"/tags/NullPointerException/"},{"name":"ArrayIndexOutOfBoundsException","slug":"ArrayIndexOutOfBoundsException","link":"/tags/ArrayIndexOutOfBoundsException/"},{"name":"NumberFormatException","slug":"NumberFormatException","link":"/tags/NumberFormatException/"},{"name":"ClassCastException","slug":"ClassCastException","link":"/tags/ClassCastException/"},{"name":"Exception","slug":"Exception","link":"/tags/Exception/"},{"name":"try","slug":"try","link":"/tags/try/"},{"name":"catch","slug":"catch","link":"/tags/catch/"},{"name":"finally","slug":"finally","link":"/tags/finally/"},{"name":"예제","slug":"예제","link":"/tags/%EC%98%88%EC%A0%9C/"},{"name":"throw","slug":"throw","link":"/tags/throw/"},{"name":"throws","slug":"throws","link":"/tags/throws/"},{"name":"Object 클래스","slug":"Object-클래스","link":"/tags/Object-%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"name":"메서드 종류","slug":"메서드-종류","link":"/tags/%EB%A9%94%EC%84%9C%EB%93%9C-%EC%A2%85%EB%A5%98/"},{"name":"toString()","slug":"toString","link":"/tags/toString/"},{"name":"hashCode()","slug":"hashCode","link":"/tags/hashCode/"}],"categories":[{"name":"JAVA","slug":"JAVA","link":"/categories/JAVA/"},{"name":"자격증 참고 자료","slug":"자격증-참고-자료","link":"/categories/%EC%9E%90%EA%B2%A9%EC%A6%9D-%EC%B0%B8%EA%B3%A0-%EC%9E%90%EB%A3%8C/"},{"name":"Utile","slug":"Utile","link":"/categories/Utile/"}],"pages":[]}